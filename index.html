<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My TV Shows</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark-charcoal: #1A202C;
            --bg-medium-charcoal: #2D3748;
            --bg-light-charcoal: #4A5568;
            --blue-primary: #4299E1;
            --blue-active-border: #3182CE;
            --blue-highlight-bg: rgba(66, 153, 225, 0.2);
            --blue-watched: #63B3ED;
            --blue-to-cyan-glow: rgba(0, 191, 255, 1.0);
            --red-primary: #E53E3E;
            --white-off: #E2E8F0;
            --white-icons: rgba(255, 255, 255, 0.8);
            --grey-text: #A0AEC0;
            --grey-buttons: #888;
            --grey-border: #4A5568;
            --shadow-light: rgba(0, 0, 0, 0.2);
            --shadow-medium: rgba(0, 0, 0, 0.4);
            --shadow-dark: rgba(0, 0, 0, 0.6);
            --button-glow-light: 0 0 8px 4px rgba(0, 191, 255, 0.6);
            --button-glow-hover: 0 0 12px 6px rgba(0, 191, 255, 0.9);
        }

        body {
            background: var(--bg-dark-charcoal);
            font-family: 'Roboto', sans-serif;
            color: var(--white-off);
            text-align: center;
            padding: 20px;
            line-height: 1.6;
            margin: 0;
            overflow-x: hidden;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: var(--bg-medium-charcoal);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 20px var(--shadow-dark);
            border: 1px solid var(--grey-border);
            position: relative;
            overflow: hidden;
        }
        h1 {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 2.5em;
            color: var(--white-off);
            letter-spacing: 1.5px;
            margin-bottom: 24px;
            text-shadow: 2px 2px 6px var(--shadow-light);
        }
        label {
            display: block;
            margin: 10px 0 5px;
            color: var(--blue-primary);
            font-weight: 600;
            font-family: 'Open Sans', sans-serif;
            font-size: 0.95em;
        }
        .select-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            max-width: 200px;
        }

        select {
            padding: 12px 18px; /* Slightly increased padding */
            font-size: 1.1em; /* Slightly increased font size */
            border-radius: 8px;
            border: 2px solid var(--blue-active-border);
            background: var(--bg-dark-charcoal);
            color: var(--white-off);
            margin-bottom: 0;
            outline: none;
            box-shadow: 0 0 0 3px var(--blue-to-cyan-glow);
            font-weight: 500;
            width: 100%;
            cursor: pointer;
        }
        select:hover, select:focus {
            border-color: var(--blue-active-border);
            box-shadow: 0 0 0 3px var(--blue-to-cyan-glow);
            outline: none;
        }

        select option {
            background-color: var(--bg-dark-charcoal);
            color: var(--white-off);
        }
        select option.watched-option {
            background-color: var(--blue-watched);
            color: #fff;
        }

        .selection-row {
            display: flex;
            justify-content: center;
            align-items: center; /* Changed to center for vertical alignment */
            flex-wrap: wrap;
            margin-bottom: 25px;
            gap: 20px;
        }

        .selects-container-desktop {
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }

        .control-group label {
            margin: 0;
            display: inline-block;
        }
        .control-group select {
            margin-bottom: 0;
        }

        .action-button {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 700;
            font-family: 'Open Sans', sans-serif;
            background-color: var(--blue-primary);
            color: #fff;
            min-width: 150px;
            display: block;
            white-space: nowrap;
            height: fit-content;
            margin-bottom: 0;
            align-self: center; /* Ensures vertical centering within a flex container */
            box-shadow: var(--button-glow-light);
            transform: translateY(0);
            transition: box-shadow 0.2s ease-in-out, transform 0.2s ease-in-out, background-color 0.2s ease-in-out, color 0.2s ease-in-out;
            text-decoration: none;
        }
        .action-button:hover, .action-button:active {
            box-shadow: var(--button-glow-hover);
            transform: translateY(-2px);
            /* Ensure no extra background/color changes beyond original design */
            background-color: var(--blue-primary);
            color: #fff;
        }

        #playBtn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        #playBtn .fas {
            font-size: 1.2em;
        }


        #videoPlayer {
            margin-top: 35px;
            border: none;
            border-radius: 12px;
            width: 100%;
            min-height: 480px;
            height: 60vh;
            background: #000;
            box-shadow: 0 0 15px 8px var(--blue-to-cyan-glow);
            margin-bottom: 25px;
        }

        #clearDataBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: var(--grey-text);
            font-size: 22px;
            cursor: pointer;
            transition: color 0.2s ease-in-out, transform 0.2s ease-in-out;
            padding: 5px; /* Adjusted padding for icon */
            z-index: 10;
        }
        #clearDataBtn:hover {
            color: var(--blue-primary);
            transform: scale(1.1);
        }
        #clearDataBtn:active {
            transform: scale(0.95);
        }

        /* --- Login/Logout/User Display --- */
        /* Login icon */
        #loginIcon {
            position: absolute;
            top: 20px;
            left: 20px; /* Position to the left */
            font-size: 22px;
            color: var(--grey-text);
            cursor: pointer;
            transition: color 0.2s ease-in-out, transform 0.2s ease-in-out;
            padding: 5px;
            z-index: 10;
        }

        #loginIcon:hover {
            color: var(--blue-primary);
            transform: scale(1.1);
        }

        /* Auth Modal styles */
        .auth-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0; /* Start hidden */
            visibility: hidden; /* Start hidden */
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .auth-modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .auth-modal-content {
            background: var(--bg-medium-charcoal);
            padding: 40px 30px; /* Increased vertical padding */
            border-radius: 12px;
            box-shadow: 0 10px 20px var(--shadow-dark);
            border: 1px solid var(--grey-border); /* Added a border */
            position: relative;
            max-width: 400px;
            width: 90%;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 25px; /* Increased gap between elements */
            transform: translateY(-20px); /* Start slightly above for animation */
            transition: transform 0.3s ease-in-out;
        }

        .auth-modal-overlay.visible .auth-modal-content {
            transform: translateY(0); /* Animate to original position */
        }

        .auth-modal-content h3 {
            color: var(--white-off);
            font-size: 2em; /* Slightly larger title */
            margin-bottom: 5px; /* Reduced margin, relying on gap */
        }

        .auth-modal-content .modal-close-btn {
            position: absolute;
            top: 10px; /* Adjusted position */
            right: 15px; /* Adjusted position */
            background: none;
            border: none;
            font-size: 32px; /* Larger close button */
            color: var(--grey-text);
            cursor: pointer;
            transition: color 0.2s, transform 0.2s;
            line-height: 1; /* Align text vertically */
        }
        .auth-modal-content .modal-close-btn:hover {
            color: var(--red-primary);
            transform: scale(1.1);
        }

        .auth-modal-content p {
            font-size: 1.1em;
            color: var(--grey-text);
            margin-top: 5px;
            margin-bottom: 0;
        }

        .auth-modal-content .auth-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-top: 10px;
        }
        .auth-modal-content .action-button {
            width: 100%; /* Ensure buttons are full width within modal */
            min-width: unset;
            padding: 14px 20px; /* Slightly larger padding for buttons */
            font-size: 1.05em; /* Slightly larger font */
            align-self: stretch; /* Make them fill width */
        }
        #loggedInUser {
            font-size: 1.1em; /* Slightly larger text */
            color: var(--grey-text);
            margin-top: 5px; /* Adjusted margin */
            text-align: center;
        }
        #loggedInUser.visible {
            display: block;
        }

        /* Custom Modal Overlay and Content Styles for notifications */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--bg-medium-charcoal);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 20px var(--shadow-dark);
            border: 1px solid var(--grey-border);
            max-width: 400px;
            width: 90%;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 15px;
            transform: translateY(-20px);
            transition: transform 0.3s ease-in-out;
        }

        .modal-overlay.visible .modal-content {
            transform: translateY(0);
        }

        .modal-content h3 {
            color: var(--white-off);
            font-size: 1.8em;
            margin-bottom: 10px;
        }

        .modal-content p {
            color: var(--grey-text);
            font-size: 1em;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 20px;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95em;
            transition: background-color 0.2s, transform 0.2s;
        }

        .modal-btn.confirm-btn {
            background-color: var(--blue-primary);
            color: #fff;
        }

        .modal-btn.confirm-btn:hover {
            background-color: var(--blue-active-border);
            transform: translateY(-2px);
        }

        .modal-btn.cancel-btn {
            background-color: var(--red-primary);
            color: #fff;
        }

        .modal-btn.cancel-btn:hover {
            background-color: #C53030;
            transform: translateY(-2px);
        }


        /* --- Episode grid/box styles like the image --- */
        #episodeListContainer {
            margin-top: 30px;
            padding: 20px;
            background: var(--bg-dark-charcoal);
            border-radius: 12px;
            box-shadow: 0 0 15px 8px var(--blue-to-cyan-glow);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 18px 16px;
            margin-bottom: 20px;
            justify-items: center;
        }
        .episode-item-rm {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background: var(--bg-medium-charcoal);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            border: 3px solid var(--bg-medium-charcoal);
            box-shadow: 0 2px 8px var(--shadow-dark);
            min-width: 160px;
            max-width: 200px;
            transition: border 0.2s, box-shadow 0.2s, background 0.2s, transform 0.2s ease-in-out;
            position: relative;
        }
        .episode-item-rm.watched {
            border: 3px solid var(--blue-watched);
            background: #222e3a;
        }
        .episode-item-rm.active {
            border: 3px solid var(--blue-active-border);
            background: var(--blue-highlight-bg);
            box-shadow: var(--button-glow-light); /* Apply glow like action buttons */
            transform: translateY(-2px); /* Lift slightly like action buttons */
        }
        /* Only episode item should have visual hover when active */
        .episode-item-rm.active:hover {
            border: 3px solid var(--blue-active-border); /* Maintain active border */
            background: var(--blue-highlight-bg); /* Maintain active background */
            box-shadow: var(--button-glow-hover); /* Stronger glow on hover for active */
            transform: translateY(-4px); /* Slightly more lift on hover for active */
        }
        /* Remove general hover for unselected episodes */
        .episode-item-rm:hover:not(.active) {
            /* No special hover effects for non-active items, revert to base or keep subtle */
            border: 3px solid var(--bg-medium-charcoal); /* Keep original border */
            box-shadow: 0 2px 8px var(--shadow-dark); /* Keep original shadow */
            transform: translateY(0); /* No lift */
        }

        .episode-thumbnail-rm {
            width: 100%;
            height: 100px;
            background: #222;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .episode-thumbnail-rm img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            border-radius: 0;
        }
        /* Remove play icon */
        .episode-play-icon-rm {
            display: none;
        }
        .episode-info-rm {
            flex-grow: 1;
            padding: 10px 12px 8px 12px;
            text-align: left;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            min-height: 70px;
            position: relative;
        }
        .episode-title-rm {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 1em;
            margin-bottom: 4px;
            color: var(--white-off);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }
        .episode-description-rm {
            font-family: 'Open Sans', sans-serif;
            font-size: 0.85em;
            color: var(--grey-text);
            line-height: 1.3;
            max-height: 2.6em; /* Show max 2 lines */
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 6px;
            width: 100%;
        }
        /* Episode Number Badge - Tiny blue square, bottom right, only on active */
        .episode-number-badge {
            position: absolute;
            bottom: 5px; /* Adjust as needed for padding */
            right: 5px; /* Adjust as needed for padding */
            background: var(--blue-active-border); /* Tiny blue square */
            color: #fff;
            border-radius: 4px; /* Make it a square */
            width: 20px; /* Tiny size */
            height: 20px; /* Tiny size */
            display: none; /* Hidden by default */
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.75em; /* Smaller font for tiny badge */
            z-index: 2;
            box-shadow: 0 1px 4px var(--shadow-dark); /* Subtle shadow */
            transition: background 0.2s, color 0.2s;
        }
        /* Show badge only on active (selected) episode */
        .episode-item-rm.active .episode-number-badge {
            display: flex;
        }
        /* No special hover for badge itself */
        .episode-number-badge:hover {
            box-shadow: 0 1px 4px var(--shadow-dark); /* Keep original shadow */
        }
        /* No watched specific styling for badge beyond active if needed */
        .episode-item-rm.watched .episode-number-badge {
            background: var(--blue-active-border); /* Keep active color */
            color: #fff;
        }

        /* Episode action buttons (Load More, Show Less) */
        .episode-action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center; /* Center buttons */
            margin-top: 20px;
        }

        .episode-action-buttons .action-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px; /* Space between icon and text */
            min-width: 180px;
        }

        /* Continue Watching Button */
        #resumeLastBtn {
            width: 100%; /* Make it full width within its flex item */
            max-width: 400px; /* Limit its max width for desktop view */
            margin: 0 auto; /* Center it horizontally */
            align-self: center; /* Align it centrally if flex-end was overriding */
        }

        /* Search Bar Styles */
        .search-container {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 500px; /* Limit search bar width */
            margin-left: auto;
            margin-right: auto;
        }

        .search-container input[type="text"] {
            flex-grow: 1;
            padding: 12px 18px;
            font-size: 1.1em;
            border-radius: 8px;
            border: 2px solid var(--blue-active-border);
            background: var(--bg-dark-charcoal);
            color: var(--white-off);
            outline: none;
            box-shadow: 0 0 0 3px var(--blue-to-cyan-glow);
            font-weight: 500;
        }

        .search-container button {
            padding: 12px; /* Make it a square for the icon */
            font-size: 1.1em;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700;
            background-color: var(--blue-primary);
            color: #fff;
            box-shadow: var(--button-glow-light);
            transition: box-shadow 0.2s ease-in-out, transform 0.2s ease-in-out;
            display: flex; /* Use flex to center icon */
            justify-content: center;
            align-items: center;
        }

        .search-container button:hover {
            box-shadow: var(--button-glow-hover);
            transform: translateY(-2px);
        }

        /* Search Results Styles */
        #searchResults {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-dark-charcoal);
            border-radius: 12px;
            box-shadow: 0 0 10px 5px rgba(0, 191, 255, 0.4);
            max-height: 400px;
            overflow-y: auto;
            display: none; /* Hidden by default, show when results are available */
        }

        .search-result-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px;
            border-bottom: 1px solid var(--grey-border);
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: left; /* Align text left */
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background-color: rgba(66, 153, 225, 0.1);
        }

        /* Remove image and date for search results */
        .search-result-item img,
        .search-result-info p {
            display: none;
        }

        .search-result-info {
            flex-grow: 1;
        }

        .search-result-info h4 {
            margin: 0;
            color: var(--white-off);
            font-size: 1.1em;
        }

        /* Remove select button */
        .search-result-select-btn {
            display: none;
        }

        /* Responsive grid for mobile */
        @media (max-width: 700px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }
            h1 {
                font-size: 2em;
            }
            .selection-row {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            .selects-container-desktop {
                flex-direction: column;
                width: 100%;
                gap: 15px;
            }
            .control-group {
                width: 100%;
                align-items: center; /* Center labels for mobile */
            }
            .select-wrapper {
                max-width: 100%; /* Full width for selects on mobile */
            }
            select {
                padding: 10px 15px; /* Adjust padding for mobile selects */
                font-size: 1em; /* Adjust font size for mobile selects */
            }

            #resumeLastBtn {
                width: 100%; /* Make Continue Watching button full width on mobile */
                max-width: 100%; /* Ensure full width on mobile */
                margin-top: 10px; /* Add some space */
            }

            #episodeListContainer {
                grid-template-columns: repeat(2, 1fr); /* Exactly 2 episodes per row */
                gap: 10px; /* Adjust gap for mobile */
                padding: 10px; /* Adjust container padding for mobile */
            }
            .episode-item-rm {
                min-width: unset; /* Remove min-width restriction */
                max-width: 100%; /* Fill available space */
                width: 100%; /* Ensure they take full grid column */
                aspect-ratio: 16/9; /* Maintain aspect ratio for thumbnails */
                height: unset; /* Let aspect-ratio control height */
            }
            .episode-thumbnail-rm {
                height: 100%; /* Thumbnail fills the item height */
                width: 100%; /* Thumbnail fills the item width */
            }
            .episode-thumbnail-rm img {
                height: 100%; /* Image fills thumbnail container */
                width: 100%; /* Image fills thumbnail container */
                object-fit: cover;
            }

            /* No title or description on mobile */
            .episode-title-rm, .episode-description-rm {
                display: none;
            }
            .episode-info-rm {
                padding: 0; /* Remove padding */
                min-height: unset; /* Remove min-height */
            }

            /* Episode number badge for mobile - remains the same as desktop logic */
            .episode-number-badge {
                width: 18px; /* Even tinier */
                height: 18px; /* Even tinier */
                font-size: 0.6em; /* Smaller font */
                bottom: 3px;
                right: 3px;
                border-radius: 3px;
            }

            /* Auth Modal positioning for mobile */
            .auth-modal-content {
                margin: 20px; /* Add some margin on smaller screens */
            }

            #clearDataBtn {
                top: 15px;
                right: 15px;
                font-size: 20px;
            }
            #loginIcon {
                top: 15px;
                left: 15px;
                font-size: 20px;
            }

            .search-container {
                flex-direction: row; /* Keep on one line for mobile */
                max-width: 100%;
                align-items: center; /* Center items vertically */
                justify-content: center; /* Center items horizontally */
            }
            .search-container input[type="text"] {
                width: auto; /* Let it grow naturally */
                flex-grow: 1; /* Take remaining space */
                min-width: 0; /* Allow shrinking */
                padding: 8px 12px; /* Smaller padding */
                font-size: 1em; /* Smaller font */
            }
            .search-container button {
                width: 40px; /* Fixed small width for icon button */
                height: 40px; /* Fixed small height for icon button */
                padding: 0; /* Remove padding */
                font-size: 1.2em; /* Ensure icon is visible */
                flex-shrink: 0; /* Prevent button from shrinking */
            }
            /* Hide the search button text on mobile */
            .search-container button span {
                display: none;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <i class="fas fa-user-circle" id="loginIcon"></i>

    <button id="clearDataBtn" title="Clear all data"><i class="fas fa-trash-alt"></i></button>
    <h1 id="showTitle">My TV Shows</h1>

    <div class="search-container">
        <input type="text" id="showSearchInput" placeholder="Search for a TV Show...">
        <button id="searchShowBtn"><i class="fas fa-search"></i></button>
    </div>

    <div id="searchResults">
        <!-- Search results will be displayed here -->
    </div>

    <div id="contentArea" class="content-area">
        <iframe id="videoPlayer" src="" frameborder="0" allowfullscreen></iframe>

        <div class="selection-row">
            <div class="selects-container-desktop">
                <div class="control-group">
                    <label for="seasonSelect">Season:</label>
                    <div class="select-wrapper">
                        <select id="seasonSelect"></select>
                    </div>
                </div>
                <div class="control-group">
                    <label for="episodeSelect">Episode:</label>
                    <div class="select-wrapper">
                        <select id="episodeSelect"></select>
                    </div>
                </div>
            </div>
            <div class="resume-btn-desktop-wrapper">
                <button id="resumeLastBtn" class="action-button">Continue Watching</button>
            </div>
        </div>
        <style>
        /* Desktop: selection left, resume right, both on top of episode list, adjustable margin-bottom */
        @media (min-width: 701px) {
            .selection-row {
                display: flex;
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-end;
                margin-bottom: 30px; /* Adjustable */
                gap: 20px;
                width: 100%;
            }
            .selects-container-desktop {
                flex: 1 1 auto;
                display: flex;
                gap: 20px;
                align-items: flex-end;
            }
            .resume-btn-desktop-wrapper {
                flex: 0 0 auto;
                display: flex;
                align-items: flex-end;
                margin-left: 30px;
                margin-bottom: 0; /* Adjustable */
            }
            #resumeLastBtn {
                max-width: 400px;
                width: auto;
                margin: 0;
                display: inline-block;
                height: 100%;
            }
        }
        /* Mobile: selects stacked, resume below, full width, adjustable margin */
        @media (max-width: 700px) {
            .selection-row {
                flex-direction: column;
                align-items: center;
                gap: 15px;
                margin-bottom: 10px; /* Adjustable */
            }
            .selects-container-desktop {
                flex-direction: column;
                width: 100%;
                gap: 15px;
            }
            .resume-btn-desktop-wrapper {
                display: flex !important;
                width: 100%;
                margin: 15px 0 15px 0; /* margin-top and margin-bottom adjustable */
                justify-content: center;
                align-items: center;
            }
            #resumeLastBtn {
                width: 100%;
                max-width: 100%;
                margin: 0;
                display: block;
            }
        }
        </style>

        <div id="episodeListContainer" style="margin-top: 30px;"></div>
        <div class="episode-action-buttons" style="margin-top: 35px;">
            <button id="loadMoreBtn" class="action-button">
            <i class="fas fa-plus-circle"></i> Load More
            </button>
            <button id="showLessBtn" class="action-button">
            <i class="fas fa-minus-circle"></i> Show Less
            </button>
        </div>
    </div>
</div>

<div id="authModalOverlay" class="auth-modal-overlay">
    <div class="auth-modal-content">
        <button class="modal-close-btn" id="authModalCloseBtn">&times;</button>
        <p id="loggedInUser"></p>
        <div class="auth-buttons">
            <a href="login.html" id="loginBtn" class="action-button">Login</a>
            <a href="login.html?mode=signup" id="signupBtn" class="action-button">Sign Up</a>
            <style>
                .auth-modal-content .auth-buttons {
                    display: flex !important;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    margin-bottom: 2rem;
                    gap: 15px;
                    width: 100%;
                }
                .auth-modal-content {
                    width: 110% !important;
                    max-width: 440px !important;
                }
                .auth-modal-content .action-button {
                    width: 80%;
                    margin: 0 auto;
                }
            </style>
            <button id="logoutBtn" class="action-button" style="display: none;">Logout</button>
        </div>
    </div>
</div>

<div id="customModalOverlay" class="modal-overlay">
    <div class="modal-content">
        <h3 id="modalTitle"></h3>
        <p id="modalMessage"></p>
        <div class="modal-buttons">
            <button id="modalConfirmBtn" class="modal-btn confirm-btn" style="display: none;">OK</button>
            <button id="modalCancelBtn" class="modal-btn cancel-btn" style="display: none;">Cancel</button>
            <button id="modalCloseBtn" class="modal-btn cancel-btn" style="display: none;">Close</button>
        </div>
    </div>
</div>

<script type="module">
    // Firebase SDK imports
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInWithCustomToken, signInAnonymously, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, collection, query, where, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // --- Global Variables (declared at the top to avoid 'access before initialization' errors) ---
    let app, db, auth;
    let userId = null;
    let isAuthReady = false; // Flag to indicate if auth state has been checked
    let firebaseInitialized = false; // Flag to indicate if firebase has been initialized successfully

    // Firestore data storage (will be updated by listeners)
    let watchedData = {}; // { [tmdb_id]: { [season]: [episode1, episode2, ...] } }
    let progressData = {}; // { [tmdb_id]: { [season]: { [episode]: seconds } } }
    let lastWatchedData = {}; // { [tmdb_id]: { season: number, episode: number, seconds: number, finished: boolean } }

    // Local Storage Fallback Keys - now include TMDB ID to differentiate data for different shows
    const WATCHED_KEY_PREFIX = 'tvShowWatched_';
    const PROGRESS_KEY_PREFIX = 'tvShowProgress_';
    const LAST_WATCHED_KEY_PREFIX = 'tvShowLastWatched_';

    // TMDB and Episode Data Constants
    const PLACEHOLDER_IMAGE = 'https://placehold.co/160x90/1A1A1A/FFFFFF?text=NO+IMAGE';
    const EPISODES_DISPLAY_WINDOW_SIZE = 10;
    const TMDB_API_KEY = 'd62d816a3f48ed18c1dc5e157f4d73b2'; // REMEMBER TO REPLACE WITH YOUR ACTUAL KEY
    const TMDB_READ_TOKEN = 'eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJkNjJkODE2YTNmNDhlZDE4YzFkYzVlMTU3ZjRkNzNiMiIsIm5iZiI6MTc0OTYyMjI0MS4wMjQsInN1YiI6IjY4NDkxZGUxMDQ2NzYwZGI4YTlmNTg1ZCIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.UXLSaRBtR2aOvUObbrT3C4ctJcNG6MXTDjh1gu8y2Ks';

    // Default show ID and name, will be updated by search
    let currentTMDBShowId = 1433; // Default to American Dad
    let currentTMDBShowName = "American Dad!"; // Default show name

    let episodeMetadata = {}; // Stores all fetched episode metadata for the current show
    let totalSeasons = 20; // Default, will be updated by TMDB fetch

    let currentSeason = 1;
    let currentEpisodesDisplayed = EPISODES_DISPLAY_WINDOW_SIZE;
    let isShowingAllEpisodes = false;

    // --- DOM Elements ---
    const showTitleElement = document.getElementById('showTitle');
    const showSearchInput = document.getElementById('showSearchInput');
    const searchShowBtn = document.getElementById('searchShowBtn');
    const searchResultsDiv = document.getElementById('searchResults');

    // --- Custom Modal Function ---
    function showCustomModal(message, type = 'alert', onConfirm = null) {
        const modalOverlay = document.getElementById('customModalOverlay');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const modalCloseBtn = document.getElementById('modalCloseBtn');

        // Hide all buttons by default
        modalConfirmBtn.style.display = 'none';
        modalCancelBtn.style.display = 'none';
        modalCloseBtn.style.display = 'none';

        // Clear previous event listeners
        modalConfirmBtn.onclick = null;
        modalCancelBtn.onclick = null;
        modalCloseBtn.onclick = null;

        modalMessage.textContent = message;

        if (type === 'confirm') {
            modalTitle.textContent = 'Confirm Action';
            modalConfirmBtn.textContent = 'Confirm';
            modalConfirmBtn.style.display = 'inline-block';
            modalCancelBtn.textContent = 'Cancel';
            modalCancelBtn.style.display = 'inline-block';

            modalConfirmBtn.onclick = () => {
                modalOverlay.classList.remove('visible'); // Hide modal with transition
                if (onConfirm) onConfirm(true);
            };
            modalCancelBtn.onclick = () => {
                modalOverlay.classList.remove('visible'); // Hide modal with transition
                if (onConfirm) onConfirm(false);
            };
        } else { // type === 'alert'
            modalTitle.textContent = 'Notification';
            modalCloseBtn.textContent = 'Close';
            modalCloseBtn.onclick = () => {
                modalOverlay.classList.remove('visible'); // Hide modal with transition
            };
            modalCloseBtn.style.display = 'inline-block';
        }
        modalOverlay.classList.add('visible'); // Show modal with transition
    }


    // --- Firebase Data Functions ---
    // Fetches the entire data object (e.g., all watchedData for all shows)
    async function getFirestoreAllData(collectionName) {
        if (!userId || !db || !firebaseInitialized) {
            console.warn(`Attempted to get Firestore doc '${collectionName}' without userId or db initialized or firebase not ready.`);
            return null;
        }
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const docRef = doc(db, `artifacts/${appId}/users/${userId}/${collectionName}/data`);
        try {
            const docSnap = await getDoc(docRef);
            return docSnap.exists() ? JSON.parse(docSnap.data().value) : null;
        } catch (e) {
            console.error(`Error fetching Firestore doc '${collectionName}':`, e);
            return null;
        }
    }

    // Sets the entire data object (e.g., all watchedData for all shows)
    async function setFirestoreAllData(collectionName, data) {
        if (!userId || !db || !firebaseInitialized) {
            console.warn(`Attempted to set Firestore doc '${collectionName}' without userId or db initialized or firebase not ready.`);
            return;
        }
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const docRef = doc(db, `artifacts/${appId}/users/${userId}/${collectionName}/data`);
        try {
            await setDoc(docRef, { value: JSON.stringify(data) }, { merge: true });
        } catch (e) {
            console.error(`Error setting Firestore doc '${collectionName}':`, e);
        }
    }

    // --- Local Storage Fallback Functions ---
    function getWatchedLocal() {
        try {
            const stored = localStorage.getItem(WATCHED_KEY_PREFIX + currentTMDBShowId);
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            console.error("Error parsing local watched data:", e);
            return {};
        }
    }

    function setWatchedLocal(watched) {
        try {
            localStorage.setItem(WATCHED_KEY_PREFIX + currentTMDBShowId, JSON.stringify(watched));
        } catch (e) {
            console.error("Error setting local watched data:", e);
        }
    }

    function getProgressLocal() {
        try {
            const stored = localStorage.getItem(PROGRESS_KEY_PREFIX + currentTMDBShowId);
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            console.error("Error parsing local progress data:", e);
            return {};
        }
    }

    function setProgressLocal(progress) {
        try {
            localStorage.setItem(PROGRESS_KEY_PREFIX + currentTMDBShowId, JSON.stringify(progress));
        } catch (e) {
            console.error("Error setting local progress data:", e);
        }
    }

    function getLastWatchedLocal() {
        try {
            const stored = localStorage.getItem(LAST_WATCHED_KEY_PREFIX + currentTMDBShowId);
            return stored ? JSON.parse(stored) : null;
        } catch (e) {
            console.error("Error parsing local last watched data:", e);
            return null;
        }
    }

    function setLastWatchedLocal(season, episode, seconds, finished) {
        try {
            localStorage.setItem(LAST_WATCHED_KEY_PREFIX + currentTMDBShowId, JSON.stringify({ season, episode, seconds, finished }));
        } catch (e) {
            console.error("Error setting local last watched data:", e);
        }
    }

    // --- Wrapped Data Access Functions (to use Firestore if logged in, else Local Storage) ---
    // These functions now return/set the data for the currentTMDBShowId
    function getWatchedCurrentShow() {
        if (userId && isAuthReady && firebaseInitialized) {
            return watchedData[currentTMDBShowId] || {};
        }
        return getWatchedLocal();
    }

    function setWatchedCurrentShow(watchedForThisShow) {
        if (userId && isAuthReady && firebaseInitialized && db) {
            watchedData[currentTMDBShowId] = watchedForThisShow;
            setFirestoreAllData('watched', watchedData); // Save the entire object
        } else {
            setWatchedLocal(watchedForThisShow);
        }
    }

    function getProgressCurrentShow() {
        if (userId && isAuthReady && firebaseInitialized) {
            return progressData[currentTMDBShowId] || {};
        }
        return getProgressLocal();
    }

    function setProgressCurrentShow(progressForThisShow) {
        if (userId && isAuthReady && firebaseInitialized && db) {
            progressData[currentTMDBShowId] = progressForThisShow;
            setFirestoreAllData('progress', progressData); // Save the entire object
        } else {
            setProgressLocal(progressForThisShow);
        }
    }

    function getLastWatchedCurrentShow() {
        if (userId && isAuthReady && firebaseInitialized) {
            return lastWatchedData[currentTMDBShowId] || null;
        }
        return getLastWatchedLocal();
    }

    function setLastWatchedCurrentShow(season, episode, seconds, finished) {
        if (userId && isAuthReady && firebaseInitialized && db) {
            if (!lastWatchedData[currentTMDBShowId]) {
                lastWatchedData[currentTMDBShowId] = {};
            }
            lastWatchedData[currentTMDBShowId] = { season, episode, seconds, finished };
            setFirestoreAllData('lastWatched', lastWatchedData); // Save the entire object
        } else {
            setLastWatchedLocal(season, episode, seconds, finished);
        }
    }


    // --- Firestore Listeners: Always update UI on change ---
    function setupFirestoreListeners() {
        if (!db || !userId || !firebaseInitialized) return;

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const watchedDocRef = doc(db, `artifacts/${appId}/users/${userId}/watched/data`);
        const progressDocRef = doc(db, `artifacts/${appId}/users/${userId}/progress/data`);
        const lastWatchedDocRef = doc(db, `artifacts/${appId}/users/${userId}/lastWatched/data`);

        onSnapshot(watchedDocRef, (docSnap) => {
            if (docSnap.exists()) {
                watchedData = JSON.parse(docSnap.data().value);
            } else {
                watchedData = {};
            }
            // Trigger UI updates only for the current show if data for it changed
            renderEpisodeSelect();
            renderEpisodeList();
            updateResumeLastButton();
        }, (error) => console.error("Error watching watched data:", error));

        onSnapshot(progressDocRef, (docSnap) => {
            if (docSnap.exists()) {
                progressData = JSON.parse(docSnap.data().value);
            } else {
                progressData = {};
            }
            renderEpisodeSelect();
            renderEpisodeList();
            updateResumeLastButton();
        }, (error) => console.error("Error watching progress data:", error));

        onSnapshot(lastWatchedDocRef, (docSnap) => {
            if (docSnap.exists()) {
                lastWatchedData = JSON.parse(docSnap.data().value);
            } else {
                lastWatchedData = {};
            }
            updateResumeLastButton();
        }, (error) => console.error("Error watching last watched data:", error));
    }


    // --- Always migrate local data to Firestore on login (merge) ---
    async function migrateLocalDataToFirestore() {
        if (!isAuthReady || !userId || !db || !firebaseInitialized) return;

        const localWatchedKeys = Object.keys(localStorage).filter(key => key.startsWith(WATCHED_KEY_PREFIX));
        const localProgressKeys = Object.keys(localStorage).filter(key => key.startsWith(PROGRESS_KEY_PREFIX));
        const localLastWatchedKeys = Object.keys(localStorage).filter(key => key.startsWith(LAST_WATCHED_KEY_PREFIX));

        let mergedWatched = await getFirestoreAllData('watched') || {};
        let mergedProgress = await getFirestoreAllData('progress') || {};
        let mergedLastWatched = await getFirestoreAllData('lastWatched') || {};

        // Migrate watched data
        localWatchedKeys.forEach(key => {
            const tmdbId = key.substring(WATCHED_KEY_PREFIX.length);
            const localShowWatched = JSON.parse(localStorage.getItem(key));
            if (!mergedWatched[tmdbId]) {
                mergedWatched[tmdbId] = {};
            }
            // Merge watched episodes (arrays)
            for (const season in localShowWatched) {
                mergedWatched[tmdbId][season] = Array.from(new Set([...(mergedWatched[tmdbId][season] || []), ...(localShowWatched[season] || [])]));
            }
            localStorage.removeItem(key);
        });

        // Migrate progress data
        localProgressKeys.forEach(key => {
            const tmdbId = key.substring(PROGRESS_KEY_PREFIX.length);
            const localShowProgress = JSON.parse(localStorage.getItem(key));
            if (!mergedProgress[tmdbId]) {
                mergedProgress[tmdbId] = {};
            }
            // Prefer the higher progress for each episode
            for (const season in localShowProgress) {
                if (!mergedProgress[tmdbId][season]) mergedProgress[tmdbId][season] = {};
                for (const episode in localShowProgress[season]) {
                    const localVal = localShowProgress[season][episode];
                    const remoteVal = (mergedProgress[tmdbId][season] && mergedProgress[tmdbId][season][episode]) || 0;
                    mergedProgress[tmdbId][season][episode] = Math.max(localVal, remoteVal);
                }
            }
            localStorage.removeItem(key);
        });

        // Migrate last watched data
        localLastWatchedKeys.forEach(key => {
            const tmdbId = key.substring(LAST_WATCHED_KEY_PREFIX.length);
            const localShowLastWatched = JSON.parse(localStorage.getItem(key));
            if (localShowLastWatched) {
                // Prefer the local if it's more recent or more progressed
                const remoteShowLastWatched = mergedLastWatched[tmdbId] || null;
                let shouldUpdate = true;
                if (remoteShowLastWatched) {
                    const localProgress = localShowLastWatched.seconds || 0;
                    const remoteProgress = (mergedProgress[tmdbId]?.[remoteShowLastWatched.season]?.[remoteShowLastWatched.episode]) || remoteShowLastWatched.seconds || 0;
                    shouldUpdate = localProgress > remoteProgress;
                }
                if (shouldUpdate) {
                    mergedLastWatched[tmdbId] = localShowLastWatched;
                }
            }
            localStorage.removeItem(key);
        });

        try {
            if (Object.keys(mergedWatched).length > 0) await setFirestoreAllData('watched', mergedWatched);
            if (Object.keys(mergedProgress).length > 0) await setFirestoreAllData('progress', mergedProgress);
            if (Object.keys(mergedLastWatched).length > 0) await setFirestoreAllData('lastWatched', mergedLastWatched);
            console.log("Local data migrated to Firebase.");
        } catch (error) {
            console.error("Error migrating data to Firebase:", error);
        }
    }

    // --- Logout Functionality ---
    document.getElementById('logoutBtn').addEventListener('click', async () => {
        if (auth) {
            try {
                await signOut(auth);
                showCustomModal('You have been logged out.', 'alert');
            } catch (error) {
                console.error("Error logging out:", error);
                showCustomModal('Error logging out. Please try again.', 'alert');
            }
        } else {
            showCustomModal('Not logged in.', 'alert');
        }
        document.getElementById('authModalOverlay').classList.remove('visible'); // Close modal on logout
    });

    // --- TMDB API Interaction for Episode Data ---
    async function fetchEpisodeData() {
        try {
            // Update the show title
            showTitleElement.textContent = currentTMDBShowName;

            const showDetailsResponse = await fetch(`https://api.themoviedb.org/3/tv/${currentTMDBShowId}`, {
                headers: {
                    'Authorization': `Bearer ${TMDB_READ_TOKEN}`,
                    'accept': 'application/json'
                }
            });
            if (!showDetailsResponse.ok) {
                throw new Error(`Failed to fetch show details: ${showDetailsResponse.statusText}`);
            }
            const showDetails = await showDetailsResponse.json();
            totalSeasons = showDetails.number_of_seasons;

            // Populate season select
            const seasonSelect = document.getElementById('seasonSelect');
            seasonSelect.innerHTML = '';
            for (let s = 1; s <= totalSeasons; s++) {
                const option = document.createElement('option');
                option.value = s;
                option.textContent = `Season ${s}`;
                seasonSelect.appendChild(option);
            }

            const seasonPromises = [];
            for (let s = 1; s <= totalSeasons; s++) {
                seasonPromises.push(
                    fetch(`https://api.themoviedb.org/3/tv/${currentTMDBShowId}/season/${s}`, {
                        headers: {
                            'Authorization': `Bearer ${TMDB_READ_TOKEN}`,
                            'accept': 'application/json'
                        }
                    }).then(res => res.ok ? res.json() : null)
                );
            }

            const seasons = await Promise.all(seasonPromises);
            episodeMetadata = {}; // Reset episode metadata for the new show
            seasons.forEach((seasonObj) => {
                const seasonNum = seasonObj?.season_number?.toString();
                if (seasonNum && seasonObj.episodes) {
                    episodeMetadata[seasonNum] = {};
                    seasonObj.episodes.forEach(ep => {
                        episodeMetadata[seasonNum][ep.episode_number.toString()] = {
                            title: ep.name || `Episode ${ep.episode_number}`,
                            description: ep.overview || 'Description not available.',
                            image: ep.still_path ? `https://image.tmdb.org/t/p/w300${ep.still_path}` : PLACEHOLDER_IMAGE
                        };
                    });
                }
            });

            // Fallback for seasons with no episodes or to ensure a minimum number of episodes
            for (let s = 1; s <= totalSeasons; s++) {
                const seasonStr = s.toString();
                if (!episodeMetadata[seasonStr]) {
                    episodeMetadata[seasonStr] = {};
                }
                const numEpisodesInSeason = Object.keys(episodeMetadata[seasonStr]).length > 0 ? Object.keys(episodeMetadata[seasonStr]).length : 22;
                for (let e = 1; e <= numEpisodesInSeason; e++) {
                    const episodeStr = e.toString();
                    if (!episodeMetadata[seasonStr][episodeStr]) {
                        episodeMetadata[seasonStr][episodeStr] = {
                            title: `Season ${s}, Episode ${e}`,
                            description: `This is a generic description for Season ${s}, Episode ${e}.`,
                            image: PLACEHOLDER_IMAGE
                        };
                    }
                }
            }

            // Set current season to 1 and episode to 1 for a new show if no last watched exists
            const lastWatched = getLastWatchedCurrentShow();
            if (lastWatched && lastWatched.season && lastWatched.episode) {
                currentSeason = lastWatched.season;
                document.getElementById('seasonSelect').value = currentSeason;
            } else {
                currentSeason = 1;
                document.getElementById('seasonSelect').value = 1;
            }


            renderEpisodeSelect();
            renderEpisodeList();
            updateResumeLastButton();
            // Automatically play the last watched or S1E1 for the new show
            if (lastWatched && lastWatched.season && lastWatched.episode) {
                updateVideoPlayer();
            } else {
                // If no last watched, start S1E1
                document.getElementById('episodeSelect').value = 1;
                updateVideoPlayer();
            }

        } catch (e) {
            console.error('Error loading episode data from TMDB API:', e);
            showCustomModal('Failed to load show data. Displaying generic content.', 'alert');
            // Populate dropdowns with default values even if TMDB fails
            const seasonSelect = document.getElementById('seasonSelect');
            if (seasonSelect.options.length === 0) {
                for (let s = 1; s <= totalSeasons; s++) {
                    const option = document.createElement('option');
                    option.value = s;
                    option.textContent = `Season ${s}`;
                    seasonSelect.appendChild(option);
                }
            }
            for (let s = 1; s <= totalSeasons; s++) {
                const seasonStr = s.toString();
                if (!episodeMetadata[seasonStr]) {
                    episodeMetadata[seasonStr] = {};
                }
                const numEpisodesInSeason = Object.keys(episodeMetadata[seasonStr]).length > 0 ? Object.keys(episodeMetadata[seasonStr]).length : 22;
                for (let e = 1; e <= numEpisodesInSeason; e++) {
                    const episodeStr = e.toString();
                    if (!episodeMetadata[seasonStr][episodeStr]) {
                        episodeMetadata[seasonStr][episodeStr] = {
                            title: `Season ${s}, Episode ${e}`,
                            description: `This is a generic description for Season ${s}, Episode ${e}.`,
                            image: PLACEHOLDER_IMAGE
                        };
                    }
                }
            }
            currentSeason = document.getElementById('seasonSelect').value;
            renderEpisodeSelect();
            renderEpisodeList();
            updateResumeLastButton();
        }
    }

    function renderEpisodeSelect() {
        const season = document.getElementById('seasonSelect').value;
        const episodeSelect = document.getElementById('episodeSelect');
        episodeSelect.innerHTML = '';
        const episodesInCurrentSeason = episodeMetadata[season] ? Object.keys(episodeMetadata[season]).length : 0;
        const numEpisodesToRender = episodesInCurrentSeason > 0 ? episodesInCurrentSeason : 22;

        for (let i = 1; i <= numEpisodesToRender; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = `Episode ${i}`;
            episodeSelect.appendChild(option);
        }
        updateEpisodeSelectColor();
    }

    function updateEpisodeSelectColor() {
        const season = document.getElementById('seasonSelect').value;
        const watched = getWatchedCurrentShow(); // Get watched data for current show
        const episodeSelect = document.getElementById('episodeSelect');

        for (let i = 0; i < episodeSelect.options.length; i++) {
            episodeSelect.options[i].classList.remove('watched-option');
            episodeSelect.options[i].style.background = '';
            episodeSelect.options[i].style.color = '';
            const episodeNum = parseInt(episodeSelect.options[i].value); // Parse to integer
            if (watched[season] && watched[season].includes(episodeNum)) {
                episodeSelect.options[i].classList.add('watched-option');
            }
        }
    }

    function renderEpisodeList() {
        const season = document.getElementById('seasonSelect').value;
        const episodeListContainer = document.getElementById('episodeListContainer');
        episodeListContainer.innerHTML = ''; // Clear existing episodes

        const episodesInSeason = episodeMetadata[season] || {};
        const episodeNumbers = Object.keys(episodesInSeason).map(Number).sort((a, b) => a - b);

        const numEpisodesToDisplay = isShowingAllEpisodes ? episodeNumbers.length : EPISODES_DISPLAY_WINDOW_SIZE;

        for (let i = 0; i < numEpisodesToDisplay; i++) {
            const episodeNum = episodeNumbers[i];
            if (!episodeNum) continue; // Skip if episode number is undefined

            const episode = episodesInSeason[episodeNum.toString()];
            if (!episode) continue; // Skip if episode data is missing

            const episodeItem = document.createElement('div');
            episodeItem.classList.add('episode-item-rm');
            episodeItem.dataset.season = season;
            episodeItem.dataset.episode = episodeNum;

            const watched = getWatchedCurrentShow(); // Get watched data for current show
            if (watched[season] && watched[season].includes(episodeNum)) {
                episodeItem.classList.add('watched');
            }

            // Set as active if it's the currently selected episode in the dropdowns
            const selectedEpisode = document.getElementById('episodeSelect').value;
            if (parseInt(season) === parseInt(currentSeason) && parseInt(episodeNum) === parseInt(selectedEpisode)) {
                episodeItem.classList.add('active');
            }

            episodeItem.innerHTML = `
                <div class="episode-thumbnail-rm">
                    <img src="${episode.image}" alt="Episode ${episodeNum} Thumbnail" onerror="this.onerror=null; this.src='${PLACEHOLDER_IMAGE}';">
                    <span class="episode-number-badge">${episodeNum}</span>
                </div>
                <div class="episode-info-rm">
                    <div class="episode-title-rm">${episode.title}</div>
                    <div class="episode-description-rm">${episode.description}</div>
                </div>
            `;
            episodeListContainer.appendChild(episodeItem);

            episodeItem.addEventListener('click', () => {
                selectEpisode(season, episodeNum);
            });
        }

        // Handle Load More/Show Less buttons visibility
        const loadMoreBtn = document.getElementById('loadMoreBtn');
        const showLessBtn = document.getElementById('showLessBtn');

        if (episodeNumbers.length > EPISODES_DISPLAY_WINDOW_SIZE) {
            if (isShowingAllEpisodes) {
                loadMoreBtn.style.display = 'none';
                showLessBtn.style.display = 'inline-block';
            } else {
                loadMoreBtn.style.display = 'inline-block';
                showLessBtn.style.display = 'none';
            }
        } else {
            loadMoreBtn.style.display = 'none';
            showLessBtn.style.display = 'none';
        }
    }

    function selectEpisode(season, episode) {
        currentSeason = parseInt(season);
        document.getElementById('seasonSelect').value = season;
        document.getElementById('episodeSelect').value = episode;
        updateVideoPlayer();
        updateEpisodeSelectColor();
        renderEpisodeList(); // Re-render to update active state and watched status
    }

    function updateVideoPlayer() {
        const season = document.getElementById('seasonSelect').value;
        const episode = document.getElementById('episodeSelect').value;
        const videoPlayer = document.getElementById('videoPlayer');

        // Check if there's progress for this episode for the current show
        const progress = getProgressCurrentShow();
        let startTime = 0;
        if (progress[season] && progress[season][episode]) {
            startTime = progress[season][episode];
        }

        // Changed to vidfast.pro
        const url = `https://vidfast.pro/tv/${currentTMDBShowId}/${season}/${episode}?autoPlay=true&nextButton=true&autoNext=true&theme=#1e90ff`;
        if (startTime > 0) {
            videoPlayer.src = `${url}#${startTime}`; // Append start time if > 0
        } else {
            videoPlayer.src = url;
        }

        // Mark as watched after playing for a certain duration (e.g., 10 seconds)
        // Removed `showCustomModal` for "marked as watched" notification
        const markWatchedTimeout = setTimeout(() => {
            let watched = getWatchedCurrentShow(); // Get watched data for current show
            if (!watched[season]) {
                watched[season] = [];
            }
            if (!watched[season].includes(parseInt(episode))) {
                watched[season].push(parseInt(episode));
                setWatchedCurrentShow(watched); // Set watched data for current show
                updateEpisodeSelectColor();
                renderEpisodeList(); // Update episode list for watched status
            }
        }, 10000); // Mark as watched after 10 seconds

        // Save last watched episode for the current show
        setLastWatchedCurrentShow(season, episode, startTime, false);
        updateResumeLastButton();
    }

    function updateResumeLastButton() {
        const resumeLastBtn = document.getElementById('resumeLastBtn');
        const lastWatched = getLastWatchedCurrentShow(); // Get last watched for current show

        if (lastWatched && lastWatched.season && lastWatched.episode && lastWatched.seconds > 0 && !lastWatched.finished) {
            resumeLastBtn.textContent = `Continue S${lastWatched.season} E${lastWatched.episode}`;
            resumeLastBtn.onclick = () => selectEpisode(lastWatched.season, lastWatched.episode);
        } else {
            // If no last watched, or it was finished, default to Start S1 E1
            resumeLastBtn.textContent = `Start S1 E1`;
            resumeLastBtn.onclick = () => selectEpisode(1, 1);
        }
        resumeLastBtn.style.display = 'inline-block'; // Always display the button
    }


    // --- Event Listeners ---
    document.getElementById('seasonSelect').addEventListener('change', () => {
        currentSeason = document.getElementById('seasonSelect').value;
        renderEpisodeSelect();
        renderEpisodeList();
        // Automatically select the first episode of the new season
        document.getElementById('episodeSelect').value = 1;
        updateVideoPlayer();
    });

    document.getElementById('episodeSelect').addEventListener('change', () => {
        updateVideoPlayer();
        renderEpisodeList(); // Re-render to update active state
    });

    // Clear Data Button
    document.getElementById('clearDataBtn').addEventListener('click', () => {
        showCustomModal('Are you sure you want to clear all watched data and progress for all shows? This cannot be undone.', 'confirm', async (response) => {
            if (response) {
                let clearedCloud = false;
                if (userId && db && firebaseInitialized) { // Only clear Firestore if a user is logged in
                    try {
                        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                        await setDoc(doc(db, `artifacts/${appId}/users/${userId}/watched/data`), { value: JSON.stringify({}) });
                        await setDoc(doc(db, `artifacts/${appId}/users/${userId}/progress/data`), { value: JSON.stringify({}) });
                        await setDoc(doc(db, `artifacts/${appId}/users/${userId}/lastWatched/data`), { value: JSON.stringify({}) }); // Clear all last watched
                        console.log("Firestore data cleared for user:", userId);
                        clearedCloud = true;
                    } catch (error) {
                        console.error("Error clearing Firestore data:", error);
                        showCustomModal('Error clearing cloud data. Please try again.', 'alert');
                    }
                }

                // Always clear local storage data and cookies for all shows
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith(WATCHED_KEY_PREFIX) || key.startsWith(PROGRESS_KEY_PREFIX) || key.startsWith(LAST_WATCHED_KEY_PREFIX)) {
                        localStorage.removeItem(key);
                    }
                });
                document.cookie.split(";").forEach(function(c) {
                    document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
                });
                console.log("Local storage and cookies cleared.");

                watchedData = {}; // Reset in-memory data
                progressData = {};
                lastWatchedData = {};

                isShowingAllEpisodes = false;
                currentEpisodesDisplayed = EPISODES_DISPLAY_WINDOW_SIZE;
                renderEpisodeSelect();
                renderEpisodeList();
                updateResumeLastButton();
                document.getElementById('videoPlayer').src = ''; // Clear video

                if (clearedCloud) {
                     showCustomModal('All data (local and cloud) has been cleared.', 'alert');
                } else {
                    showCustomModal('All local data has been cleared. Cloud data was not cleared as you were not logged in or Firebase was not initialized.', 'alert');
                }

                if (window.watchTimer) clearInterval(window.watchTimer);
            }
        });
    });

    // Load More/Show Less buttons
    document.getElementById('loadMoreBtn').addEventListener('click', () => {
        isShowingAllEpisodes = true;
        renderEpisodeList();
    });

    document.getElementById('showLessBtn').addEventListener('click', () => {
        isShowingAllEpisodes = false;
        renderEpisodeList();
    });

    // --- Search Functionality ---
    searchShowBtn.addEventListener('click', () => {
        const query = showSearchInput.value.trim();
        if (query) {
            searchShows(query);
        } else {
            // Removed specific alert "Please enter a show name to search."
            searchResultsDiv.innerHTML = '<p style="color: var(--grey-text);">Please enter a show name.</p>';
            searchResultsDiv.style.display = 'block';
        }
    });

    showSearchInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            searchShowBtn.click();
        }
    });

    async function searchShows(query) {
        searchResultsDiv.innerHTML = '<p style="color: var(--grey-text);">Searching...</p>';
        searchResultsDiv.style.display = 'block';
        try {
            const response = await fetch(`https://api.themoviedb.org/3/search/tv?query=${encodeURIComponent(query)}&api_key=${TMDB_API_KEY}`);
            if (!response.ok) {
                throw new Error(`Failed to search shows: ${response.statusText}`);
            }
            const data = await response.json();
            displaySearchResults(data.results);
        } catch (error) {
            console.error('Error searching shows:', error);
            searchResultsDiv.innerHTML = '<p style="color: var(--red-primary);">Error searching for shows. Please try again.</p>';
        }
    }

    function displaySearchResults(results) {
        searchResultsDiv.innerHTML = '';
        if (results.length === 0) {
            searchResultsDiv.innerHTML = '<p style="color: var(--grey-text);">No results found.</p>';
            return;
        }

        results.forEach(show => {
            const resultItem = document.createElement('div');
            resultItem.classList.add('search-result-item');
            // Display only the show name
            resultItem.innerHTML = `<h4>${show.name}</h4>`;
            searchResultsDiv.appendChild(resultItem);

            resultItem.addEventListener('click', () => {
                currentTMDBShowId = show.id;
                currentTMDBShowName = show.name;
                searchResultsDiv.style.display = 'none'; // Hide search results
                showSearchInput.value = ''; // Clear search input
                fetchEpisodeData(); // Load data for the newly selected show
            });
        });
    }

    // --- Firebase Initialization ---
    document.addEventListener('DOMContentLoaded', async () => {
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : null;
        const loggedInUserDiv = document.getElementById('loggedInUser');
        const loginBtn = document.getElementById('loginBtn');
        const signupBtn = document.getElementById('signupBtn');
        const logoutBtn = document.getElementById('logoutBtn');
        const authModalOverlay = document.getElementById('authModalOverlay');
        const authModalCloseBtn = document.getElementById('authModalCloseBtn');
        const loginIcon = document.getElementById('loginIcon');

        // Event listener for opening the auth modal
        if (loginIcon) {
            loginIcon.addEventListener('click', () => {
                authModalOverlay.classList.add('visible');
            });
        }

        // Event listener for closing the auth modal
        if (authModalCloseBtn) {
            authModalCloseBtn.addEventListener('click', () => {
                authModalOverlay.classList.remove('visible');
            });
        }

        // Close modal if clicked outside content
        if (authModalOverlay) {
            authModalOverlay.addEventListener('click', (event) => {
                if (event.target === authModalOverlay) {
                    authModalOverlay.classList.remove('visible');
                }
            });
        }

        try {
            if (firebaseConfig && Object.keys(firebaseConfig).length > 0 && firebaseConfig.apiKey && firebaseConfig.apiKey !== "YOUR_API_KEY_HERE") {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                firebaseInitialized = true;
                console.log("Firebase initialized successfully.");

                onAuthStateChanged(auth, async (user) => {
                    isAuthReady = true; // Auth state has been checked
                    if (user) {
                        userId = user.uid;
                        loggedInUserDiv.textContent = `Logged in as: ${user.email || 'Anonymous'} (ID: ${userId})`;
                        loggedInUserDiv.classList.add('visible');
                        loginBtn.style.display = 'none';
                        signupBtn.style.display = 'none';
                        logoutBtn.style.display = 'inline-block';
                        document.getElementById('clearDataBtn').style.display = 'none'; // Hide clear local data button

                        // Load all data from Firestore
                        watchedData = await getFirestoreAllData('watched') || {};
                        progressData = await getFirestoreAllData('progress') || {};
                        lastWatchedData = await getFirestoreAllData('lastWatched') || {};

                        // Migrate local data to Firestore on successful login
                        await migrateLocalDataToFirestore();

                        setupFirestoreListeners();
                        console.log("User logged in:", userId);
                    } else {
                        userId = null;
                        loggedInUserDiv.textContent = 'Running in local mode (ID: anonymous)';
                        loggedInUserDiv.classList.add('visible');
                        loginBtn.style.display = 'inline-block'; // Keep login/signup visible for potential future setup
                        signupBtn.style.display = 'inline-block';
                        logoutBtn.style.display = 'none';
                        document.getElementById('clearDataBtn').style.display = 'inline-block'; // Allow clearing local data

                        // Clear global Firebase data, rely on local for current show
                        watchedData = {};
                        progressData = {};
                        lastWatchedData = {};
                    }
                    // Always fetch episode data for the current show, regardless of Firebase status, to populate the UI
                    fetchEpisodeData();
                });

                // Attempt initial sign-in: first with custom token if available, then anonymously
                if (!auth.currentUser) {
                    try {
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            await signInWithCustomToken(auth, __initial_auth_token);
                            console.log("Attempted sign-in with custom token.");
                        } else {
                            await signInAnonymously(auth);
                            console.log("Attempted anonymous sign-in.");
                        }
                    } catch (initialSignInError) {
                        console.error("Error during initial sign-in (anonymous or custom token):", initialSignInError.code, initialSignInError.message);
                        if (initialSignInError.code === 'auth/admin-restricted-operation') {
                             showCustomModal("Anonymous authentication is not enabled in your Firebase project. Please enable it in Firebase console (Authentication -> Sign-in method -> Anonymous). Running in local-only mode.", "alert");
                             firebaseInitialized = false;
                             isAuthReady = true;
                             userId = null;
                             loggedInUserDiv.textContent = 'Running in local mode (ID: anonymous)';
                             loggedInUserDiv.classList.add('visible');
                             loginBtn.style.display = 'inline-block';
                             signupBtn.style.display = 'inline-block';
                             logoutBtn.style.display = 'none';
                             document.getElementById('clearDataBtn').style.display = 'inline-block';
                        } else {
                            showCustomModal(`Initial authentication failed: ${initialSignInError.message}. Running in local-only mode.`, "alert");
                            firebaseInitialized = false;
                            isAuthReady = true;
                            userId = null;
                            loggedInUserDiv.textContent = 'Running in local mode (ID: anonymous)';
                            loggedInUserDiv.classList.add('visible');
                            loginBtn.style.display = 'inline-block';
                            signupBtn.style.display = 'inline-block';
                            logoutBtn.style.display = 'none';
                            document.getElementById('clearDataBtn').style.display = 'inline-block';
                        }
                        // Load local data in case of Firebase auth failure
                        watchedData = {}; // Clear global Firebase data
                        progressData = {};
                        lastWatchedData = {};
                    }
                }

            } else {
                console.warn("Firebase config not found or incomplete. Running in local-only mode.");
                // Fallback to local-only mode if Firebase config is missing
                firebaseInitialized = false;
                isAuthReady = true; // Mark auth ready even if Firebase failed
                userId = null; // No user ID in local-only mode
                loggedInUserDiv.textContent = 'Running in local mode (ID: anonymous)';
                loggedInUserDiv.classList.add('visible');
                loginBtn.style.display = 'inline-block'; // Keep login/signup visible for potential future setup
                signupBtn.style.display = 'inline-block';
                logoutBtn.style.display = 'none';
                document.getElementById('clearDataBtn').style.display = 'inline-block'; // Allow clearing local data

                // Load data from local storage for current show
                watchedData = {}; // Clear global Firebase data
                progressData = {};
                lastWatchedData = {};
            }
        } catch (e) {
            console.error("Failed to initialize Firebase outer block:", e); // Catch any errors from initializeApp itself
            // Fallback to local-only mode if Firebase initialization fails
            firebaseInitialized = false;
            isAuthReady = true; // Mark auth ready even if Firebase failed
            userId = null; // No user ID
            loggedInUserDiv.textContent = 'Running in local mode (ID: anonymous)';
            loggedInUserDiv.classList.add('visible');
            loginBtn.style.display = 'inline-block'; // Keep login/signup visible for potential future setup
            signupBtn.style.display = 'inline-block';
            logoutBtn.style.display = 'none';
            document.getElementById('clearDataBtn').style.display = 'inline-block'; // Allow clearing local data

            // Load data from local storage for current show
            watchedData = {}; // Clear global Firebase data
            progressData = {};
            lastWatchedData = {};
        } finally {
             // Initial fetch of episode data is now handled by onAuthStateChanged
             // or by the catch block if firebase setup fails entirely.
        }
    });

</script>

</body>
</html>
