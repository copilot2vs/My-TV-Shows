<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Corrected viewport for consistent mobile experience -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <title>My TV Shows</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark-charcoal: #1A202C;
            --bg-medium-charcoal: #2D3748;
            --bg-light-charcoal: #4A5568;
            --blue-primary: #4299E1;
            --blue-active-border: #3182CE;
            --blue-highlight-bg: rgba(66, 153, 225, 0.2);
            --blue-watched: #63B3ED;
            --blue-to-cyan-glow: rgba(0, 191, 255, 1.0);
            --red-primary: #E53E3E;
            --white-off: #E2E8F0;
            --white-icons: rgba(255, 255, 255, 0.8);
            --grey-text: #A0AEC0;
            --grey-buttons: #888;
            --grey-border: #4A5568;
            --shadow-light: rgba(0, 0, 0, 0.2);
            --shadow-medium: rgba(0, 0, 0, 0.4);
            --shadow-dark: rgba(0, 0, 0, 0.6);
            --button-glow-light: 0 0 8px 4px rgba(0, 191, 255, 0.6);
            --button-glow-hover: 0 0 12px 6px rgba(0, 191, 255, 0.9);

            /* New glow colors for consistent application */
            --constant-glow-color: rgba(66, 153, 225, 0.2); /* A softer blue for constant glow */
            --strong-glow-color: rgba(66, 153, 225, 0.6); /* For hover/active states */

            /* Defined glow for video player and episode list container */
            --video-player-glow: 0 0 10px 5px var(--blue-to-cyan-glow);
        }
        body {
            background: var(--bg-dark-charcoal);
            font-family: 'Roboto', sans-serif;
            color: var(--white-off);
            text-align: center;
            padding: 20px;
            line-height: 1.6;
            margin: 0;
            overflow-x: hidden;
            -webkit-tap-highlight-color: transparent; /* Attempt to remove blue tap highlight on mobile */
            display: flex; /* Make body a flex container */
            flex-direction: column; /* Stack children vertically */
            align-items: center; /* Center children horizontally */
            min-height: 100vh; /* Ensure body takes full viewport height */
            box-sizing: border-box; /* Include padding in element's total width and height */
        }
        .container {
            max-width: 900px;
            /* margin: 0 auto; Removed auto margins on container if body is a flex column */
            background: var(--bg-medium-charcoal);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 20px var(--shadow-dark);
            border: 1px solid var(--grey-border);
            position: relative;
            overflow: hidden;
            flex-shrink: 0; /* Prevent container from shrinking */
            width: 100%; /* Take full available width, centered by body's align-items */
        }
        .header-icons-container {
            display: flex;
            justify-content: flex-start; /* Align to start, then use margin/gap */
            gap: 15px; /* Space between icons */
            padding: 10px 20px; /* Padding for the container */
            width: 100%; /* Take full width */
            box-sizing: border-box; /* Include padding in width */
            position: absolute; /* Position the container itself */
            top: 0;
            left: 0;
            right: 0;
            z-index: 10; /* Ensure it's above other content */
        }
        .header-icon {
            background: none;
            border: none;
            color: var(--grey-text);
            font-size: 24px; /* Slightly larger */
            cursor: pointer;
            transition: color 0.2s ease-in-out, transform 0.2s ease-in-out, text-shadow 0.2s ease-in-out;
            padding: 5px;
            z-index: 10;
        }
        .header-icon:hover {
            color: var(--blue-primary);
            transform: scale(1.1);
            text-shadow: 0 0 8px var(--blue-primary); /* Add text shadow on hover */
        }
        #clearDataBtn {
            margin-left: auto; /* Pushes this button to the right */
        }
        h1 {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 2.5em;
            color: var(--white-off);
            letter-spacing: 1.5px;
            margin-top: 60px; /* More space from the top for new header-icons-container */
            margin-bottom: 24px;
            text-shadow: 2px 2px 6px var(--shadow-light);
        }
        /* Enhanced styling for dropdown labels */
        label {
            display: block;
            margin: 0 0 8px; /* Adjusted margin for clearer separation from dropdown */
            color: var(--blue-primary);
            font-weight: 700; /* Made bolder */
            font-family: 'Open Sans', sans-serif;
            font-size: 1.2em; /* Significantly larger */
            letter-spacing: 0.5px; /* Added subtle letter spacing */
            text-shadow: 1px 1px 4px var(--shadow-dark); /* Stronger text shadow */
        }
        .selection-row {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 25px;
            gap: 20px;
        }
        .selects-container-desktop {
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }
        .control-group label {
            margin: 0;
            display: inline-block;
        }
        .action-button {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 700;
            font-family: 'Open Sans', sans-serif;
            background-color: var(--blue-primary);
            color: #fff;
            min-width: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap;
            height: fit-content;
            /* Increased blue shadow brightness with more opacity */
            box-shadow:
            0 2px 8px rgba(0, 64, 255, 0.32),
            0 8px 24px rgba(66, 153, 225, 0.38),
            0 0 16px 4px rgba(66, 153, 225, 0.32);
            margin-bottom: 0;
            align-self: center;
            transform: translateY(0);
            transition: transform 0.2s, background-color 0.2s, color 0.2s, box-shadow 0.2s;
            text-decoration: none;
        }
        .action-button:hover, .action-button:active {
            transform: translateY(-2px);
            background-color: var(--blue-active-border);
            color: #fff;
            box-shadow:
            0 6px 24px rgba(66, 153, 225, 0.48),
            0 1.5px 6px rgba(66,153,225,0.36),
            0 0 24px 8px rgba(66,153,225,0.44);
        }
        .action-button i, .action-button span {
            pointer-events: none;
        }
        #videoPlayer {
            margin-top: 15px; /* Less space from search bar */
            border: none;
            border-radius: 12px;
            width: 100%;
            min-height: 480px;
            height: 60vh;
            background: #000;
            /* Applying the defined video player glow */
            box-shadow: var(--video-player-glow);
            margin-bottom: 25px;
            transition: box-shadow 0.3s ease; /* Add transition for smooth effect */
            outline: none; /* Remove default outline */
        }
        /* No extra glow on hover for video player - use the same glow as active */
        #videoPlayer:hover {
            box-shadow: var(--video-player-glow);
        }
        .custom-dropdown {
            position: relative;
            width: 100%;
            max-width: 200px;
            margin-bottom: 0;
        }
        .dropdown-display {
            padding: 14px 20px; /* Increased padding */
            font-size: 1.15em; /* Slightly larger font */
            border-radius: 10px; /* More rounded corners */
            border: 2px solid var(--grey-border); /* Thicker border */
            background: linear-gradient(145deg, var(--bg-dark-charcoal), var(--bg-medium-charcoal)); /* Subtle gradient */
            color: var(--white-off);
            outline: none;
            box-shadow: 0 0 12px 5px var(--strong-glow-color);
            font-weight: 500;
            width: 100%;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            transition: border-color 0.3s, box-shadow 0.3s, background 0.3s;
            height: 55px; /* Increased height */
        }
        .dropdown-display:hover {
            border-color: var(--blue-active-border);
            box-shadow: 0 0 28px 10px var(--blue-to-cyan-glow), 0 0 8px 2px var(--blue-primary);
            background: linear-gradient(145deg, var(--bg-medium-charcoal), var(--bg-dark-charcoal));
            color: #fff;
        }
        .dropdown-display.open {
            border-color: var(--blue-active-border); /* Distinct border when open */
            box-shadow: 0 0 15px var(--blue-to-cyan-glow); /* Glow when open */
        }
        .dropdown-display::after {
            content: '\f078';
            font-family: "Font Awesome 5 Free";
            font-weight: 900;
            margin-left: 10px;
            transition: transform 0.2s;
            color: var(--blue-primary); /* Blue arrow icon */
        }
        .dropdown-display.open::after {
            transform: rotate(180deg);
            color: var(--blue-active-border); /* Darker blue arrow when open */
        }
        .dropdown-options {
            position: absolute;
            top: calc(100% + 5px); /* Slightly below the display box */
            left: 0;
            width: 100%;
            background: var(--bg-dark-charcoal);
            border: 1px solid var(--blue-active-border); /* Distinct border for options */
            border-radius: 8px; /* Rounded corners */
            box-shadow: 0 8px 20px var(--shadow-dark); /* Stronger shadow */
            max-height: 250px; /* Slightly more height */
            overflow-y: auto;
            z-index: 100;
            display: none;
            list-style: none;
            padding: 5px 0; /* Adjusted padding */
            margin: 0;
        }
        .dropdown-options.open {
            display: block;
        }
        .dropdown-options li {
            padding: 12px 20px; /* Increased padding for options */
            font-size: 1.05em; /* Slightly larger font */
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s, color 0.2s;
            outline: none;
            border-radius: 6px; /* Subtle rounded corners for each option */
            margin: 0 5px; /* Margin to make options slightly inset */
            background: transparent;
            color: var(--white-off);
        }
        .dropdown-options li:hover,
        .dropdown-options li.focused {
            background-color: var(--blue-primary);
            color: #fff;
        }

        #episodeListContainer {
            margin-top: 30px;
            padding: 20px;
            background: var(--bg-dark-charcoal);
            border-radius: 12px;
            box-shadow: 0 5px 15px var(--shadow-dark); /* Added shadow */
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 18px 16px;
            margin-bottom: 20px;
            justify-items: center;
            /* Glow for episode list container - matches video player */
            box-shadow: var(--video-player-glow);
        }
        .episode-item-rm {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background: var(--bg-medium-charcoal);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            border: none !important;
            box-shadow: 0 2px 8px var(--shadow-dark);
            min-width: 160px;
            max-width: 200px;
            transition: box-shadow 0.2s ease-in-out, transform 0.2s ease-in-out;
            position: relative;
            outline: none !important;
        }
        .episode-item-rm:focus,
        .episode-item-rm:focus-visible,
        .episode-thumbnail-rm:focus,
        .episode-thumbnail-rm img:focus {
            outline: none !important;
            box-shadow: none !important;
        }
        .episode-item-rm.watched {
            border: none !important;
            background: #222e3a;
        }
        .episode-item-rm.active {
            border: none !important;
            background: transparent;
            box-shadow: 0 0 10px 5px var(--blue-to-cyan-glow);
            transform: translateY(0);
            outline: none !important;
        }
        .episode-item-rm.active:hover {
            /* Ensure active state maintains its glow even on hover */
            box-shadow: 0 0 10px 5px var(--blue-to-cyan-glow);
            transform: translateY(0);
            background: transparent;
            outline: none !important;
        }
        .episode-item-rm:hover:not(.active) {
            border: none !important;
            box-shadow: 0 2px 8px var(--shadow-medium);
            transform: translateY(-2px);
            outline: none !important;
        }
        .episode-thumbnail-rm {
            width: 100%;
            height: 100px;
            background: #222;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 9px;
        }
        .episode-thumbnail-rm img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            border-radius: 9px;
        }
        .episode-item-rm {
            border-radius: 12px;
        }
        .episode-play-icon-rm {
            display: none;
        }
        .episode-number-badge {
            display: none !important;
        }
        .episode-overlay-info {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #fff;
            z-index: 1;
            border-radius: 9px;
        }
        .episode-overlay-info .overlay-episode-number {
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .episode-overlay-info .overlay-episode-title {
            font-size: 0.9em;
            font-weight: 500;
            white-space: normal;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 0 10px;
        }
        .episode-info-below-thumbnail {
            flex-grow: 1;
            padding: 10px 12px 8px 12px;
            text-align: left;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            min-height: 70px;
            position: relative;
            z-index: 0;
        }
        .episode-info-below-thumbnail .episode-title-rm {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 1em;
            margin-bottom: 4px;
            color: var(--white-off);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }
        .episode-info-below-thumbnail .episode-description-rm {
            font-family: 'Open Sans', sans-serif;
            font-size: 0.85em;
            color: var(--grey-text);
            line-height: 1.3;
            max-height: 2.6em;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 6px;
            width: 100%;
        }
        .episode-item-rm.active .episode-overlay-info {
            display: flex;
        }
        .episode-item-rm.active .episode-info-below-thumbnail {
            display: none;
        }

        /* Enhanced styling for the search container */
        .search-container {
            display: flex;
            gap: 15px; /* Increased gap */
            margin-bottom: 15px; /* Consistent spacing from video player */
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 650px; /* Slightly wider search bar */
            background: var(--bg-medium-charcoal);
            padding: 20px 25px; /* Increased padding */
            border-radius: 30px; /* More rounded */
            box-shadow: 0 0 10px 4px var(--constant-glow-color); /* Constant subtle blue glow */
            border: 1px solid var(--blue-active-border); /* More visible border */
            position: relative; /* For potential future additions */
            overflow: hidden; /* To keep inner elements rounded */
            box-sizing: border-box; /* Include padding in element's total width and height */
            align-self: center; /* Ensure it centers itself within the flex body */
        }
        .search-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(145deg, rgba(66, 153, 225, 0.05), rgba(0, 191, 255, 0.02)); /* Subtle inner glow */
            border-radius: inherit;
            pointer-events: none;
            z-index: 0;
        }
        .search-container input[type="text"] {
            flex-grow: 1;
            padding: 16px 25px; /* Increased padding */
            font-size: 1.2em; /* Larger font */
            border-radius: 25px; /* Keeps rounded shape */
            border: none; /* Border handled by container */
            background: var(--bg-dark-charcoal);
            color: var(--white-off);
            outline: none;
            font-weight: 500;
            box-shadow: inset 0 3px 8px rgba(0, 0, 0, 0.6); /* Deeper inner shadow */
            transition: all 0.3s ease;
            z-index: 1; /* Ensure it's above the pseudo-element */
            box-shadow: inset 0 3px 8px rgba(0, 0, 0, 0.8), 0 0 15px var(--blue-primary); /* Stronger glow on focus */
        }
        .search-container input[type="text"]:focus {
            background-color: #262c38; /* Slightly lighter background on focus */
            box-shadow: inset 0 3px 8px rgba(0, 0, 0, 0.8), 0 0 15px var(--blue-primary); /* Stronger glow on focus */
        }
        .search-container button {
            padding: 15px 25px; /* Adjusted padding to match input height */
            font-size: 1.3em; /* Larger icon/text */
            border-radius: 25px; /* More rounded */
            border: none;
            cursor: pointer;
            font-weight: 700;
            background-color: var(--blue-primary);
            color: #fff;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); /* Stronger shadow for button */
            transition: transform 0.2s ease-in-out, background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px; /* Space between icon and text if text is added */
            z-index: 1; /* Ensure it's above the pseudo-element */
        }
        .search-container button:hover {
            transform: translateY(-3px); /* More pronounced lift */
            background-color: var(--blue-active-border); /* Darker blue on hover */
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5); /* Even stronger shadow on hover */
        }
        #searchResults {
            margin-top: 25px; /* Adjusted margin */
            padding: 20px; /* Increased padding */
            background: var(--bg-dark-charcoal);
            border-radius: 15px; /* More rounded */
            box-shadow: 0 0 12px 6px var(--strong-glow-color); /* Stronger glow */
            max-height: 400px;
            overflow-y: auto;
            display: none;
            text-align: left;
            border: 1px solid var(--blue-primary); /* Added border */
        }
        .search-result-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px 15px; /* Increased padding */
            border-bottom: 1px solid var(--grey-border);
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            max-width: 100%;
            box-sizing: border-box;
            border-radius: 8px; /* Added subtle border radius */
        }
        .search-result-item:last-child {
            border-bottom: none;
        }
        .search-result-item:hover {
            background-color: var(--blue-highlight-bg); /* Use highlight background */
            transform: translateX(5px); /* Subtle slide effect on hover */
        }
        .search-result-item h4 {
            color: var(--white-off);
            margin: 0;
            font-size: 1.1em;
            font-weight: 600;
        }
        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--blue-primary);
            font-size: 1.2em;
            font-weight: 600;
            gap: 10px;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--blue-primary);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background: var(--bg-medium-charcoal);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 30px var(--shadow-dark);
            border: 1px solid var(--grey-border);
            width: 90%;
            max-width: 500px; /* Default max-width for desktop */
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }
        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }
        .modal-content h3 {
            margin-top: 0;
            color: var(--white-off);
            font-size: 1.5em;
        }
        .modal-content p {
            margin: 15px 0;
            color: var(--grey-text);
        }
        .modal-buttons {
            margin-top: 25px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .modal-btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.2s;
        }
        .modal-btn.confirm-btn {
            background-color: var(--blue-primary);
            color: #fff;
        }
        .modal-btn.confirm-btn:hover {
            background-color: var(--blue-active-border);
            transform: translateY(-2px);
        }
        .modal-btn.cancel-btn {
            background-color: var(--bg-light-charcoal);
            color: var(--white-off);
        }
        .modal-btn.cancel-btn:hover {
            background-color: #5A6578;
            transform: translateY(-2px);
        }

        /* Server Selection Modal Specific Styles for better UI */
        .server-selection-modal .modal-content {
            padding: 25px 30px; /* Increased padding */
            border: 2px solid var(--blue-primary); /* More prominent border */
            box-shadow: 0 0 25px rgba(66, 153, 225, 0.4); /* Stronger blue glow */
            background: linear-gradient(145deg, var(--bg-medium-charcoal) 10%, #262e3d 90%); /* Subtle gradient */
        }
        .server-option-group {
            margin-top: 20px;
            text-align: left;
            display: flex;
            flex-direction: column;
            gap: 15px; /* Space between radio button items */
        }
        .server-option-group label {
            display: flex; /* Make label a flex container for alignment */
            align-items: center;
            font-size: 1.1em;
            color: var(--white-off);
            cursor: pointer;
            transition: color 0.2s;
            padding: 8px 0; /* Padding for click area */
        }
        .server-option-group label:hover {
            color: var(--blue-primary);
        }
        .server-option-group input[type="radio"] {
            margin-right: 12px; /* Space between radio and text */
            transform: scale(1.3); /* Larger radio buttons */
            accent-color: var(--blue-primary); /* Blue accent color */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .aggregator-info-display {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-dark-charcoal);
            border-radius: 8px;
            border: 1px solid var(--grey-border);
            text-align: center;
            font-size: 0.95em;
            color: var(--grey-text);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.3); /* Inner shadow */
        }
        .aggregator-info-display p {
            margin: 0;
            color: var(--white-off); /* Make text more visible */
            font-weight: 500;
        }
        /* Hide if no aggregators are needed */
        .aggregator-info-display:empty {
            display: none;
        }

        @media (max-width: 700px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }
            h1 {
                font-size: 2em;
                margin-top: 50px; /* Adjusted for mobile title spacing */
            }
            .selection-row {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            .selects-container-desktop {
                flex-direction: column;
                width: 100%;
                gap: 15px;
            }
            .control-group {
                width: 100%;
                align-items: center;
            }
            /* Align server title to center on mobile */
            .control-group label[for="serverSelectDisplay"] {
                text-align: center;
                width: 100%;
            }
            .custom-dropdown {
                max-width: 100%;
            }
            #episodeListContainer {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                padding: 10px;
            }
            .episode-item-rm {
                min-width: unset;
                max-width: 100%;
                width: 100%;
                height: auto;
                aspect-ratio: 16/9;
            }
            .episode-thumbnail-rm {
                height: 100%;
                border-radius: 9px;
            }
            .episode-thumbnail-rm img {
                border-radius: 9px;
            }
            .episode-info-below-thumbnail {
                display: none;
            }
            .episode-item-rm.active .episode-overlay-info {
                display: flex;
            }
            /* Smaller modal windows on mobile */
            .modal-content {
                max-width: 90%; /* Smaller max-width */
                padding: 20px; /* Reduced padding */
            }
            .server-selection-modal .modal-content {
                padding: 15px; /* Even smaller padding for server modal */
            }
            .search-container {
                flex-direction: row;
                max-width: 100%;
                align-items: center;
                justify-content: center;
                padding: 10px 15px; /* Adjusted padding for mobile */
                gap: 10px; /* Adjusted gap for mobile */
                margin-bottom: 15px; /* Consistent spacing for mobile */
            }
            .search-container input[type="text"] {
                width: auto;
                flex-grow: 1;
                min-width: 0;
                padding: 10px 15px; /* Adjusted padding for mobile */
                font-size: 1em;
            }
            .search-container button {
                width: 45px; /* Slightly larger touch target */
                height: 45px;
                padding: 0;
                font-size: 1.3em; /* Larger icon */
                flex-shrink: 0;
            }
            .search-container button span {
                display: none;
            }
        }
        @media (min-width: 701px) { /* Apply these styles for desktop (screens wider than 700px) */
            .episode-item-rm {
                height: auto;
                aspect-ratio: 16/9;
            }
            .episode-thumbnail-rm {
                height: 100%;
                border-radius: 9px;
            }
            .episode-thumbnail-rm img {
                border-radius: 9px;
            }
            .episode-info-below-thumbnail {
                display: none;
            }
            .episode-item-rm.active .episode-overlay-info {
                display: flex;
            }
            .search-container {
                margin-left: auto;
                margin-right: auto;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <div class="header-icons-container">
        <a href="Library.html" id="libraryBtn" class="header-icon" title="My Library"><i class="fas fa-layer-group"></i></a>
        <button id="serverBtn" class="header-icon" title="Change Server"><i class="fas fa-globe"></i></button>
        <button id="clearDataBtn" class="header-icon" title="Clear all data"><i class="fas fa-trash-alt"></i></button>
    </div>
    <h1 id="showTitle">My TV Shows</h1>

    <div class="search-container">
        <input type="text" id="showSearchInput" placeholder="Search for a TV Show...">
        <button id="searchShowBtn"><i class="fas fa-search"></i></button>
    </div>

    <div id="searchResults"></div>

    <div id="mainContentLoading" class="loading-indicator" style="display: none;">
        <div class="loading-spinner"></div>
        <span>Loading show data...</span>
    </div>

    <div id="contentArea" class="content-area">
        <iframe id="videoPlayer" src="" frameborder="0" allowfullscreen allow="autoplay"></iframe>

        <div class="selection-row">
            <div class="selects-container-desktop">
                <div class="control-group">
                    <label for="seasonSelectDisplay">Season:</label>
                    <div id="seasonSelect" class="custom-dropdown" role="combobox" aria-haspopup="listbox" aria-expanded="false" aria-labelledby="seasonSelectDisplay">
                        <div class="dropdown-display" id="seasonSelectDisplay" tabindex="0">Season 1</div>
                        <ul class="dropdown-options" id="seasonOptions" role="listbox"></ul>
                    </div>
                </div>
                <div class="control-group">
                    <label for="episodeSelectDisplay">Episode:</label>
                    <div id="episodeSelect" class="custom-dropdown" role="combobox" aria-haspopup="listbox" aria-expanded="false" aria-labelledby="episodeSelectDisplay">
                        <div class="dropdown-display" id="episodeSelectDisplay" tabindex="0">Episode 1</div>
                        <ul class="dropdown-options" id="episodeOptions" role="listbox"></ul>
                    </div>
                </div>
            </div>
        </div>

        <div id="episodeListContainer" style="margin-top: 30px;"></div>
        <div class="episode-action-buttons" style="margin-top: 35px;">
            <button id="loadMoreBtn" class="action-button">
            <i class="fas fa-plus-circle"></i> <span>Load More</span>
            </button>
            <button id="showLessBtn" class="action-button">
            <i class="fas fa-minus-circle"></i> <span>Show Less</span>
            </button>
        </div>
    </div>
</div>

<div id="customModalOverlay" class="modal-overlay">
    <div class="modal-content">
        <h3 id="modalTitle"></h3>
        <p id="modalMessage"></p>
        <div class="modal-buttons">
            <button id="modalConfirmBtn" class="modal-btn confirm-btn" style="display: none;">OK</button>
            <button id="modalCancelBtn" class="modal-btn cancel-btn" style="display: none;">Cancel</button>
            <button id="modalCloseBtn" class="modal-btn cancel-btn" style="display: none;">Close</button>
        </div>
    </div>
</div>

<div id="serverSelectionModalOverlay" class="modal-overlay server-selection-modal">
    <div class="modal-content">
        <h3>Select Playback Server</h3>
        <div class="server-option-group">
            <label>
                <input type="radio" id="serverVidfast" name="server" value="vidfast">
                Vidfast (Ad-Supported)
            </label>
            <label>
                <input type="radio" id="serverRivestream" name="server" value="rivestream">
                Rivestream (Ad-Free)
            </label>
        </div>

        <div id="aggregatorInfo" class="aggregator-info-display" style="display: none;">
            <p>Using Default Ad-Free Player (Aggregator 32).</p>
        </div>

        <div class="modal-buttons">
            <button id="saveServerSelectionBtn" class="modal-btn confirm-btn">Save</button>
            <button id="cancelServerSelectionBtn" class="modal-btn cancel-btn">Cancel</button>
        </div>
    </div>
</div>

<script type="module">
    // Constants for Local Storage Keys
    const WATCHED_KEY_PREFIX = 'tvShowWatched_';
    const LAST_WATCHED_KEY_PREFIX = 'tvShowLastWatched_';
    const MANUAL_PROGRESS_KEY_PREFIX = 'manualProgress_';
    const LAST_SHOW_ID_KEY = 'lastActiveShowId';
    // FIX: Standardized LAST_SHOW_NAME_KEY to match Library.html
    const LAST_SHOW_NAME_KEY = 'lastActiveShowName'; 
    const LAST_SERVER_KEY = 'lastActiveServer';
    const LAST_AGGREGATOR_KEY = 'lastActiveAggregator';

    // Default values and API keys
    const PLACEHOLDER_IMAGE = 'https://placehold.co/160x90/1A1A1A/FFFFFF?text=NO+IMAGE';
    const EPISODES_DISPLAY_WINDOW_SIZE = 10;
    const TMDB_API_KEY = 'd62d816a3f48ed18c1dc5e157f4d73b2';
    const TMDB_READ_TOKEN = 'eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJkNjJkODE2YTNmNDhlZDE4YzFkYzVlMTU3ZjRkNzNiMiIsIm5iZiI6MTc0OTYyMjI0MS4wMjQsInN1YiI6IjY4NDkxZGUxMDQ2NzYwZGI4YTlmNTg1ZCIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.UXLSaRBtR2aOvUObbrT3C4ctJcNG6MXTDjh1gu8y2Ks';

    // Global state variables
    let currentTMDBShowId = 1433; // Default to American Dad!
    let currentTMDBShowName = "American Dad!";
    let currentServer = "vidfast";
    let currentRivestreamAggregator = "32"; // Default aggregator for Rivestream

    let episodeMetadata = {}; // Stores details fetched from TMDB for each episode
    let totalSeasons = 20;

    let currentSeason = 1;
    let currentEpisode = 1;
    let isShowingAllEpisodes = false;
    let isLoadingData = false;

    // DOM Element References
    const showTitleElement = document.getElementById('showTitle');
    const showSearchInput = document.getElementById('showSearchInput');
    const searchShowBtn = document.getElementById('searchShowBtn');
    const searchResultsDiv = document.getElementById('searchResults');
    const mainContentLoadingDiv = document.getElementById('mainContentLoading');
    const videoPlayer = document.getElementById('videoPlayer');
    const episodeListContainer = document.getElementById('episodeListContainer');

    // Season & Episode Dropdown elements
    const seasonSelectDiv = document.getElementById('seasonSelect');
    const seasonSelectDisplay = document.getElementById('seasonSelectDisplay');
    const seasonOptionsUl = document.getElementById('seasonOptions');

    const episodeSelectDiv = document.getElementById('episodeSelect');
    const episodeSelectDisplay = document.getElementById('episodeSelectDisplay');
    const episodeOptionsUl = document.getElementById('episodeOptions');

    const loadMoreBtn = document.getElementById('loadMoreBtn');
    const showLessBtn = document.getElementById('showLessBtn');

    // Server Selection Modal Elements
    const serverBtn = document.getElementById('serverBtn');
    const serverSelectionModalOverlay = document.getElementById('serverSelectionModalOverlay');
    const serverVidfastRadio = document.getElementById('serverVidfast');
    const serverRivestreamRadio = document.getElementById('serverRivestream');
    const aggregatorInfoDiv = document.getElementById('aggregatorInfo');

    const saveServerSelectionBtn = document.getElementById('saveServerSelectionBtn');
    const cancelServerSelectionBtn = document.getElementById('cancelServerSelectionBtn');

    /**
     * Listens for messages from the iframe to get current playback time (Vidfast only).
     * This helps in saving the last watched position accurately.
     */
    window.addEventListener('message', (event) => {
        // Only process messages from vidfast.pro if current server is vidfast
        if (currentServer === "vidfast" && event.origin && !event.origin.includes('vidfast.pro')) return;
        if (typeof event.data === 'object' && event.data && event.data.type === 'currentTime') {
            const lastIframeTime = Math.floor(event.data.time || 0);
            setLastWatchedCurrentShow(currentSeason, currentEpisode, lastIframeTime, false);
            updateManualProgress(currentSeason, currentEpisode, lastIframeTime);
        }
    });

    /**
     * Requests the current time from the iframe video player (Vidfast only).
     * This is typically triggered when the iframe loses focus.
     */
    function requestIframeCurrentTime() {
        if (currentServer === "vidfast" && videoPlayer && videoPlayer.contentWindow) {
            videoPlayer.contentWindow.postMessage({ type: 'getCurrentTime' }, '*');
        }
    }

    // Event listener for video player blur (losing focus)
    videoPlayer.addEventListener('blur', requestIframeCurrentTime);

    // Event listener to close dropdowns when clicking outside
    document.addEventListener('click', (event) => {
        if (!seasonSelectDiv.contains(event.target)) closeDropdown(seasonSelectDisplay, seasonOptionsUl);
        if (!episodeSelectDiv.contains(event.target)) closeDropdown(episodeSelectDisplay, episodeOptionsUl);
    });

    /**
     * Displays a custom modal for alerts or confirmations.
     * @param {string} message - The message to display in the modal.
     * @param {'alert'|'confirm'} type - The type of modal ('alert' or 'confirm').
     * @param {function(boolean):void} [onConfirm=null] - Callback function for 'confirm' type.
     */
    function showCustomModal(message, type = 'alert', onConfirm = null) {
        const modalOverlay = document.getElementById('customModalOverlay');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const modalCloseBtn = document.getElementById('modalCloseBtn');

        // Hide all buttons initially
        modalConfirmBtn.style.display = 'none';
        modalCancelBtn.style.display = 'none';
        modalCloseBtn.style.display = 'none';

        // Clear previous event listeners
        modalConfirmBtn.onclick = null;
        modalCancelBtn.onclick = null;
        modalCloseBtn.onclick = null;

        modalMessage.textContent = message;

        if (type === 'confirm') {
            modalTitle.textContent = 'Confirm Action';
            modalConfirmBtn.style.display = 'inline-block';
            modalCancelBtn.style.display = 'inline-block';
            modalConfirmBtn.onclick = () => {
                modalOverlay.classList.remove('visible');
                if (onConfirm) onConfirm(true);
            };
            modalCancelBtn.onclick = () => {
                modalOverlay.classList.remove('visible');
                if (onConfirm) onConfirm(false);
            };
        } else { // 'alert' type
            modalTitle.textContent = 'Notification';
            modalCloseBtn.style.display = 'inline-block';
            modalCloseBtn.onclick = () => modalOverlay.classList.remove('visible');
        }
        modalOverlay.classList.add('visible'); // Make modal visible
    }

    // --- Local Storage Management Functions ---

    /**
     * Retrieves the 'watched' status for the current show from local storage.
     * @returns {Object} An object where keys are season numbers and values are arrays of watched episode numbers.
     */
    function getWatchedLocal() {
        const stored = localStorage.getItem(WATCHED_KEY_PREFIX + currentTMDBShowId);
        return stored ? JSON.parse(stored) : {};
    }

    /**
     * Saves the 'watched' status for the current show to local storage.
     * @param {Object} watched - The object containing watched episode information.
     */
    function setWatchedLocal(watched) {
        localStorage.setItem(WATCHED_KEY_PREFIX + currentTMDBShowId, JSON.stringify(watched));
    }

    /**
     * Retrieves the last watched episode and season for the current show.
     * @returns {Object|null} An object with season, episode, seconds, finished status, and timestamp, or null if not found.
     */
    function getLastWatchedLocal() {
        const stored = localStorage.getItem(LAST_WATCHED_KEY_PREFIX + currentTMDBShowId);
        return stored ? JSON.parse(stored) : null;
    }

    /**
     * Saves the last watched episode and season for the current show, along with progress.
     * @param {number} season - The season number.
     * @param {number} episode - The episode number.
     * @param {number} seconds - The current playback time in seconds.
     * @param {boolean} finished - True if the episode was finished.
     */
    function setLastWatchedLocal(season, episode, seconds, finished) {
        const data = {
            season,
            episode,
            seconds,
            finished,
            showName: currentTMDBShowName,
            lastWatchedTimestamp: Date.now() // Record timestamp for sorting in library
        };
        localStorage.setItem(LAST_WATCHED_KEY_PREFIX + currentTMDBShowId, JSON.stringify(data));
    }

    /**
     * Retrieves manually set progress for a specific episode.
     * @param {number} season - The season number.
     * @param {number} episode - The episode number.
     * @returns {number} The manually saved progress in seconds, or 0 if not found.
     */
    function getManualProgress(season, episode) {
        const key = `${MANUAL_PROGRESS_KEY_PREFIX}${currentTMDBShowId}_${season}_${episode}`;
        const stored = localStorage.getItem(key);
        return stored ? parseInt(stored) : 0;
    }

    /**
     * Updates manually set progress for a specific episode.
     * @param {number} season - The season number.
     * @param {number} episode - The episode number.
     * @param {number} seconds - The progress in seconds to save.
     */
    function updateManualProgress(season, episode, seconds) {
        const key = `${MANUAL_PROGRESS_KEY_PREFIX}${currentTMDBShowId}_${season}_${episode}`;
        localStorage.setItem(key, seconds.toString());
    }

    // Helper functions for current show
    function getWatchedCurrentShow() { return getWatchedLocal(); }
    function setWatchedCurrentShow(watchedForThisShow) { setWatchedLocal(watchedForThisShow); }
    function getLastWatchedCurrentShow() { return getLastWatchedLocal(); }
    function setLastWatchedCurrentShow(season, episode, seconds, finished) {
        setLastWatchedLocal(season, episode, seconds, finished);
    }

    /**
     * Fetches TV show and episode data from TMDB API.
     * Updates season/episode dropdowns and episode list based on fetched data.
     * Also sets the initial video player source.
     */
    async function fetchEpisodeData() {
        isLoadingData = true;
        mainContentLoadingDiv.style.display = 'flex';
        document.getElementById('contentArea').style.display = 'none';

        try {
            showTitleElement.textContent = currentTMDBShowName; // Always update show title based on current selection
            
            // Basic validation for TMDB_READ_TOKEN
            if (!TMDB_READ_TOKEN) {
                throw new Error("TMDB_READ_TOKEN is missing. Please provide a valid TMDB API key or read access token.");
            }

            // Fetch general show details to get total seasons
            const showDetailsResponse = await fetch(`https://api.themoviedb.org/3/tv/${currentTMDBShowId}`, {
                headers: { 'Authorization': `Bearer ${TMDB_READ_TOKEN}`, 'accept': 'application/json' }
            });
            if (!showDetailsResponse.ok) {
                const errorData = await showDetailsResponse.json().catch(() => ({}));
                throw new Error(`Failed to fetch show details: ${showDetailsResponse.status} - ${errorData.status_message || showDetailsResponse.statusText}.`);
            }
            const showDetails = await showDetailsResponse.json();
            totalSeasons = showDetails.number_of_seasons;

            // Fetch data for all seasons concurrently
            const seasonPromises = Array.from({ length: totalSeasons }, (_, i) =>
                fetch(`https://api.themoviedb.org/3/tv/${currentTMDBShowId}/season/${i + 1}`, {
                    headers: { 'Authorization': `Bearer ${TMDB_READ_TOKEN}`, 'accept': 'application/json' }
                }).then(res => res.ok ? res.json() : null) // Return null if fetch fails for a season
            );

            const seasons = await Promise.all(seasonPromises);
            episodeMetadata = {};
            seasons.forEach(seasonObj => {
                const seasonNum = seasonObj?.season_number?.toString();
                if (seasonNum && seasonObj.episodes) {
                    episodeMetadata[seasonNum] = Object.fromEntries(
                        seasonObj.episodes.map(ep => [
                            ep.episode_number.toString(),
                            {
                                title: ep.name || `Episode ${ep.episode_number}`,
                                description: ep.overview || 'Description not available.',
                                image: ep.still_path ? `https://image.tmdb.org/t/p/w300${ep.still_path}` : PLACEHOLDER_IMAGE
                            }
                        ])
                    );
                }
            });

            // Determine current season and episode to load based on last watched, or default to S1E1
            const lastWatched = getLastWatchedCurrentShow();
            if (lastWatched && lastWatched.season && lastWatched.episode) {
                // Check if the last watched season/episode still exists in the fetched metadata
                if (episodeMetadata[lastWatched.season] && episodeMetadata[lastWatched.season][lastWatched.episode]) {
                    currentSeason = lastWatched.season;
                    currentEpisode = lastWatched.episode;
                } else {
                    // Fallback to S1E1 if last watched episode/season is no longer valid (e.g., deleted from TMDB)
                    currentSeason = 1;
                    currentEpisode = 1;
                }
            } else {
                currentSeason = 1;
                currentEpisode = 1;
            }

            isShowingAllEpisodes = false; // Reset episode display mode
            renderSeasonSelect(); // Populate season dropdown
            renderEpisodeSelect(); // Populate episode dropdown
            renderEpisodeList(true); // Render episode cards (full refresh)
            updateVideoPlayer(true); // Load video player (initial load allows seeking)
        } catch (e) {
            console.error('Error loading episode data:', e);
            showCustomModal(`Failed to load show data: ${e.message}. Please check your internet connection or try again later.`, 'alert');
        } finally {
            isLoadingData = false;
            document.getElementById('contentArea').style.display = 'block';
            mainContentLoadingDiv.style.display = 'none';
        }
    }

    /**
     * Creates a dropdown option list item.
     * @param {string|number} value - The data-value attribute for the list item.
     * @param {string} text - The text content of the list item.
     * @param {boolean} isWatched - True if the option represents a watched episode/season.
     * @returns {HTMLElement} The created li element.
     */
    function createDropdownOption(value, text, isWatched) {
        const li = document.createElement('li');
        li.dataset.value = value;
        li.textContent = text;
        li.setAttribute('role', 'option');
        if (isWatched) li.classList.add('watched-option');
        return li;
    }

    /**
     * Opens a custom dropdown.
     * @param {HTMLElement} displayElement - The element that triggers the dropdown (e.g., seasonSelectDisplay).
     * @param {HTMLElement} optionsListElement - The ul element containing the options.
     */
    function openDropdown(displayElement, optionsListElement) {
        displayElement.classList.add('open');
        displayElement.setAttribute('aria-expanded', 'true');
        optionsListElement.classList.add('open');
    }

    /**
     * Closes a custom dropdown.
     * @param {HTMLElement} displayElement - The element that triggers the dropdown.
     * @param {HTMLElement} optionsListElement - The ul element containing the options.
     */
    function closeDropdown(displayElement, optionsListElement) {
        displayElement.classList.remove('open');
        displayElement.setAttribute('aria-expanded', 'false');
        optionsListElement.classList.remove('open');
        // Remove focus class from any focused option
        optionsListElement.querySelectorAll('.focused').forEach(el => el.classList.remove('focused'));
    }

    /**
     * Populates the season dropdown with available seasons.
     */
    function renderSeasonSelect() {
        seasonOptionsUl.innerHTML = ''; // Clear existing options
        for (let s = 1; s <= totalSeasons; s++) {
            const li = createDropdownOption(s, `Season ${s}`, false); // Watched status not applicable for seasons
            seasonOptionsUl.appendChild(li);
            li.addEventListener('click', () => {
                selectSeason(parseInt(li.dataset.value));
                closeDropdown(seasonSelectDisplay, seasonOptionsUl);
            });
        }
        seasonSelectDisplay.textContent = `Season ${currentSeason}`; // Set display text
    }

    /**
     * Populates the episode dropdown with episodes for the current season.
     * Marks episodes as watched if they are.
     */
    function renderEpisodeSelect() {
        episodeOptionsUl.innerHTML = ''; // Clear existing options
        const episodesInSeason = episodeMetadata[currentSeason] || {};
        const numEpisodes = Object.keys(episodesInSeason).length;

        const watched = getWatchedCurrentShow();
        for (let i = 1; i <= numEpisodes; i++) {
            const isWatched = watched[currentSeason] && watched[currentSeason].includes(i);
            const li = createDropdownOption(i, `Episode ${i}`, isWatched);
            episodeOptionsUl.appendChild(li);
            li.addEventListener('click', () => {
                selectEpisode(currentSeason, parseInt(li.dataset.value));
                closeDropdown(episodeSelectDisplay, episodeOptionsUl);
            });
        }
        episodeSelectDisplay.textContent = `Episode ${currentEpisode}`; // Set display text
    }

    // Event listeners for dropdown display clicks
    seasonSelectDisplay.addEventListener('click', () => {
        const isOpen = seasonOptionsUl.classList.contains('open');
        if (isOpen) closeDropdown(seasonSelectDisplay, seasonOptionsUl);
        else {
            openDropdown(seasonSelectDisplay, seasonOptionsUl);
            closeDropdown(episodeSelectDisplay, episodeOptionsUl); // Close other dropdown
        }
    });

    episodeSelectDisplay.addEventListener('click', () => {
        const isOpen = episodeOptionsUl.classList.contains('open');
        if (isOpen) closeDropdown(episodeSelectDisplay, episodeOptionsUl);
        else {
            openDropdown(episodeSelectDisplay, episodeOptionsUl);
            closeDropdown(seasonSelectDisplay, seasonOptionsUl); // Close other dropdown
        }
    });

    /**
     * Handles keyboard navigation for custom dropdowns.
     * @param {KeyboardEvent} event - The keyboard event.
     * @param {HTMLElement} displayElement - The element that triggers the dropdown.
     * @param {HTMLElement} optionsListElement - The ul element containing the options.
     * @param {function(string):void} selectFn - The function to call when an option is selected.
     */
    function handleDropdownKeyboard(event, displayElement, optionsListElement, selectFn) {
        if (!['Enter', ' ', 'Escape', 'ArrowDown', 'ArrowUp'].includes(event.key)) return;
        event.preventDefault(); // Prevent default scroll behavior for arrow keys

        const isOpen = optionsListElement.classList.contains('open');
        if (event.key === 'Escape') {
            closeDropdown(displayElement, optionsListElement);
            displayElement.focus(); // Return focus to the display element
            return;
        }
        if (event.key === 'Enter' || event.key === ' ') {
            if (isOpen) {
                const currentFocused = optionsListElement.querySelector('.focused');
                if (currentFocused) selectFn(currentFocused.dataset.value);
                closeDropdown(displayElement, optionsListElement);
            } else {
                openDropdown(displayElement, optionsListElement);
            }
            return;
        }

        // Handle ArrowUp/ArrowDown
        if (!isOpen) openDropdown(displayElement, optionsListElement);
        const options = Array.from(optionsListElement.children);
        let currentFocused = optionsListElement.querySelector('.focused');
        let nextIndex = 0;

        if (currentFocused) {
            const currentIndex = options.indexOf(currentFocused);
            currentFocused.classList.remove('focused');
            if (event.key === 'ArrowDown') nextIndex = (currentIndex + 1) % options.length;
            else nextIndex = (currentIndex - 1 + options.length) % options.length;
        } else if (event.key === 'ArrowUp') {
            nextIndex = options.length - 1; // Wrap around to last item if no item is focused
        }
        
        if (options[nextIndex]) {
            options[nextIndex].classList.add('focused');
            options[nextIndex].scrollIntoView({ block: 'nearest' }); // Scroll to make focused item visible
        }
    }

    // Attach keyboard event listeners to dropdown displays
    seasonSelectDisplay.addEventListener('keydown', (event) => handleDropdownKeyboard(event, seasonSelectDisplay, seasonOptionsUl, (value) => selectSeason(parseInt(value))));
    episodeSelectDisplay.addEventListener('keydown', (event) => handleDropdownKeyboard(event, episodeSelectDisplay, episodeOptionsUl, (value) => selectEpisode(currentSeason, parseInt(value))));

    /**
     * Changes the currently selected season and loads its first episode.
     * @param {number} seasonNum - The new season number.
     */
    function selectSeason(seasonNum) {
        if (currentSeason === seasonNum) return; // No change needed
        currentSeason = seasonNum;
        currentEpisode = 1; // Always reset to first episode of the new season
        setLastWatchedCurrentShow(currentSeason, currentEpisode, 0, false); // Update last watched
        renderEpisodeSelect(); // Re-render episode dropdown for new season
        isShowingAllEpisodes = false; // Reset episode display to windowed view
        renderEpisodeList(true); // Re-render episode cards fully
        updateVideoPlayer(false); // Load video player for new episode
        seasonSelectDisplay.textContent = `Season ${currentSeason}`; // Update display text
    }

    /**
     * Changes the currently selected episode.
     * @param {number} season - The season number of the episode.
     * @param {number} episode - The new episode number.
     */
    function selectEpisode(season, episode) {
        currentSeason = season; // Update current season
        currentEpisode = episode; // Update current episode
        setLastWatchedCurrentShow(currentSeason, currentEpisode, 0, false); // Update last watched
        episodeSelectDisplay.textContent = `Episode ${currentEpisode}`; // Update display text
        renderEpisodeList(false); // Re-render episode cards (no full refresh, just active state update)
        updateVideoPlayer(false); // Load video player for new episode
    }

    /**
     * Renders or updates the list of episode cards.
     * @param {boolean} fullRefresh - If true, clears and re-renders the entire list.
     */
    function renderEpisodeList(fullRefresh = false) {
        if (fullRefresh) {
            episodeListContainer.innerHTML = ''; // Clear all existing cards
        }
        const episodesInSeason = episodeMetadata[currentSeason] || {};
        // Get episode numbers, convert to number, and sort numerically
        const episodeNumbers = Object.keys(episodesInSeason).map(Number).sort((a, b) => a - b);
        
        // Determine how many episodes to display initially or if showing all
        const targetDisplayCount = isShowingAllEpisodes ? episodeNumbers.length : EPISODES_DISPLAY_WINDOW_SIZE;

        const fragment = document.createDocumentFragment();
        // Determine starting index for appending new episodes
        const startIndex = fullRefresh ? 0 : episodeListContainer.children.length;

        // Iterate and create episode cards
        for (let i = startIndex; i < targetDisplayCount && i < episodeNumbers.length; i++) {
            const episodeNum = episodeNumbers[i];
            const episode = episodesInSeason[episodeNum.toString()];
            if (!episode) continue; // Skip if episode data is missing

            const episodeItem = document.createElement('div');
            episodeItem.className = 'episode-item-rm';
            episodeItem.dataset.season = currentSeason;
            episodeItem.dataset.episode = episodeNum;
            episodeItem.innerHTML = `
                <div class="episode-thumbnail-rm">
                    <img src="${episode.image}" alt="Episode Thumbnail" onerror="this.onerror=null; this.src='${PLACEHOLDER_IMAGE}';">
                    <div class="episode-overlay-info">
                        <div class="overlay-episode-number">Episode ${episodeNum}</div>
                        <div class="overlay-episode-title">${episode.title}</div>
                    </div>
                </div>
                <div class="episode-info-below-thumbnail">
                    <div class="episode-title-rm">${episode.title}</div>
                    <div class="episode-description-rm">${episode.description}</div>
                </div>
            `;
            // Add click listener to select the episode
            episodeItem.addEventListener('click', () => {
                selectEpisode(parseInt(episodeItem.dataset.season), parseInt(episodeItem.dataset.episode));
            });
            fragment.appendChild(episodeItem);
        }
        // Append newly created cards if any
        if (fragment.children.length > 0) {
            episodeListContainer.appendChild(fragment);
        }

        // Update 'watched' and 'active' classes for all visible episode cards
        const watched = getWatchedCurrentShow();
        episodeListContainer.querySelectorAll('.episode-item-rm').forEach(item => {
            const isWatched = watched[item.dataset.season]?.includes(parseInt(item.dataset.episode));
            item.classList.toggle('watched', isWatched);
            const isActive = parseInt(item.dataset.season) === currentSeason && parseInt(item.dataset.episode) === currentEpisode;
            item.classList.toggle('active', isActive);
        });

        // Manage visibility of "Load More" and "Show Less" buttons
        const canLoadMore = episodeNumbers.length > EPISODES_DISPLAY_WINDOW_SIZE;
        loadMoreBtn.style.display = canLoadMore && !isShowingAllEpisodes ? 'inline-flex' : 'none';
        showLessBtn.style.display = canLoadMore && isShowingAllEpisodes ? 'inline-flex' : 'none';
    }

    /**
     * Updates the video player's source based on the current show, season, episode, and server.
     * @param {boolean} initialLoad - True if this is the initial load of the video player, allowing seeking from last watched time.
     */
    function updateVideoPlayer(initialLoad = false) {
        let url = '';
        videoPlayer.src = 'about:blank'; // Clear existing iframe content to prevent old video playing
        if (window.markWatchedTimeout) clearTimeout(window.markWatchedTimeout); // Clear any existing 'mark as watched' timeout

        if (currentServer === "vidfast") {
            let secondsToStart = 0;
            if (initialLoad) {
                const lastWatched = getLastWatchedCurrentShow();
                if (lastWatched && lastWatched.season === currentSeason && lastWatched.episode === currentEpisode && lastWatched.seconds > 0 && !lastWatched.finished) {
                    secondsToStart = lastWatched.seconds;
                } else if (lastWatched && lastWatched.season === currentSeason && lastWatched.episode === currentEpisode && lastWatched.seconds === 0) {
                    // If vidfast's last watched time is 0, attempt to use manual progress
                    const manualProgress = getManualProgress(currentSeason, currentEpisode);
                    if (manualProgress > 0) {
                        secondsToStart = manualProgress;
                    }
                }
            }
            // Construct Vidfast URL. Autoplay is not explicitly enabled here by parameter due to Vidfast's embed behavior.
            url = `https://vidfast.pro/tv/${currentTMDBShowId}/${currentSeason}/${currentEpisode}?nextButton=true&autoNext=true&theme=#1e90ff`;
            if (secondsToStart > 0) {
                url += `#${secondsToStart}`; // Append timestamp for seeking
            }

            // Set a timeout to mark episode as watched after a short duration (e.g., 10 seconds)
            // This is a heuristic for Vidfast as it doesn't provide fine-grained progress updates.
            window.markWatchedTimeout = setTimeout(() => {
                let watched = getWatchedCurrentShow();
                if (!watched[currentSeason]) watched[currentSeason] = [];
                if (!watched[currentSeason].includes(currentEpisode)) {
                    watched[currentSeason].push(currentEpisode);
                    setWatchedCurrentShow(watched);
                    renderEpisodeSelect(); // Update watched status in dropdown
                    renderEpisodeList(false); // Update watched status in episode cards
                }
            }, 10000); // Mark as watched after 10 seconds
        } else if (currentServer === "rivestream") {
            // Construct Rivestream URL with hardcoded aggregator 32 and autoplay enabled
            // `muted=1` is typically required for autoplay to work in browsers.
            url = `https://rivestream.org/embed?type=tv&id=${currentTMDBShowId}&season=${currentSeason}&episode=${currentEpisode}&agg=32&autoplay=true&muted=1`;

            // For Rivestream, mark as watched immediately since there's no direct progress tracking from their embed.
            let watched = getWatchedCurrentShow();
            if (!watched[currentSeason]) watched[currentSeason] = [];
            if (!watched[currentSeason].includes(currentEpisode)) {
                watched[currentSeason].push(currentEpisode);
                setWatchedCurrentShow(watched);
                renderEpisodeSelect(); // Update watched status in dropdown
                renderEpisodeList(false); // Update watched status in episode cards
            }
        }

        // Set the iframe source if it's different from the current source
        if (videoPlayer.src !== url) videoPlayer.src = url;
    }

    // --- Server Selection Modal Logic ---

    // Open server selection modal
    serverBtn.addEventListener('click', () => {
        // Set initial state of radio buttons based on currentServer
        if (currentServer === "vidfast") {
            serverVidfastRadio.checked = true;
            aggregatorInfoDiv.style.display = 'none'; // Hide aggregator info for Vidfast
        } else { // rivestream
            serverRivestreamRadio.checked = true;
            aggregatorInfoDiv.style.display = 'block'; // Show aggregator info for Rivestream
        }
        serverSelectionModalOverlay.classList.add('visible'); // Make modal visible
    });

    // Handle change for Vidfast radio button
    serverVidfastRadio.addEventListener('change', () => {
        if (serverVidfastRadio.checked) {
            aggregatorInfoDiv.style.display = 'none';
        }
    });

    // Handle change for Rivestream radio button
    serverRivestreamRadio.addEventListener('change', () => {
        if (serverRivestreamRadio.checked) {
            aggregatorInfoDiv.style.display = 'block';
        }
    });

    // Save selected server and update video player
    saveServerSelectionBtn.addEventListener('click', () => {
        const selectedServer = document.querySelector('input[name="server"]:checked').value;
        let newAggregator = "32"; // Aggregator is always 32 for Rivestream now

        // Only update if server or aggregator (for Rivestream) has changed
        if (currentServer !== selectedServer || (selectedServer === "rivestream" && currentRivestreamAggregator !== newAggregator)) {
            currentServer = selectedServer;
            currentRivestreamAggregator = newAggregator; // Update aggregator
            localStorage.setItem(LAST_SERVER_KEY, currentServer);
            localStorage.setItem(LAST_AGGREGATOR_KEY, currentRivestreamAggregator);
            updateVideoPlayer(false); // Reload video with new server/aggregator settings
        }
        serverSelectionModalOverlay.classList.remove('visible'); // Hide modal
    });

    // Cancel server selection
    cancelServerSelectionBtn.addEventListener('click', () => {
        serverSelectionModalOverlay.classList.remove('visible'); // Hide modal
    });

    // --- Clear All Data Functionality ---

    // Event listener for clear data button
    document.getElementById('clearDataBtn').addEventListener('click', () => {
        showCustomModal('Are you sure you want to clear all data? This cannot be undone.', 'confirm', (response) => {
            if (response) {
                // Iterate through local storage and remove relevant keys
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('tvShow') || key.startsWith('lastActive') || key.startsWith(MANUAL_PROGRESS_KEY_PREFIX)) {
                        localStorage.removeItem(key);
                    }
                });
                videoPlayer.src = 'about:blank'; // Clear video player
                // Reset to default show and server settings
                currentTMDBShowId = 2288; // Default to Prison Break ID
                currentTMDBShowName = "Prison Break"; // Default to Prison Break Name
                currentServer = "rivestream"; // Default to Rivestream for ad-free experience
                currentRivestreamAggregator = "32"; // Reset aggregator to default
                fetchEpisodeData(); // Re-fetch data for the default show
                showCustomModal('All local data has been cleared.', 'alert');
            }
        });
    });

    // --- Load More / Show Less Episodes ---

    // Event listener for "Load More" button
    loadMoreBtn.addEventListener('click', () => {
        isShowingAllEpisodes = true; // Set flag to show all episodes
        renderEpisodeList(false); // Re-render without full refresh (just append remaining)
    });

    // Event listener for "Show Less" button
    showLessBtn.addEventListener('click', () => {
        isShowingAllEpisodes = false; // Set flag to show only a window of episodes
        renderEpisodeList(true); // Full refresh to show only the windowed view
    });

    // --- TV Show Search Functionality ---

    /**
     * Performs a TV show search using the TMDB API.
     * @param {string} query - The search query.
     */
    async function searchShows(query) {
        searchResultsDiv.innerHTML = `<div class="loading-indicator"><div class="loading-spinner"></div><span>Searching...</span></div>`;
        searchResultsDiv.style.display = 'block'; // Show loading indicator
        if (!TMDB_READ_TOKEN) {
            searchResultsDiv.innerHTML = `<p style="color: var(--red-primary);">TMDB API Token is missing. Please provide a valid TMDB API key or read access token.</p>`;
            return;
        }
        try {
            const response = await fetch(`https://api.themoviedb.org/3/search/tv?query=${encodeURIComponent(query)}`, {
                headers: { 'Authorization': `Bearer ${TMDB_READ_TOKEN}`, 'accept': 'application/json' }
            });
            if (!response.ok) throw new Error(`Search failed: ${response.statusText}`);
            const data = await response.json();
            displaySearchResults(data.results); // Display search results
        } catch (error) {
            console.error('Error searching shows:', error);
            searchResultsDiv.innerHTML = `<p style="color: var(--red-primary);">Error: ${error.message}.</p>`;
        }
    }

    /**
     * Displays the search results in a list.
     * @param {Array<Object>} results - An array of TV show objects from TMDB.
     */
    function displaySearchResults(results) {
        searchResultsDiv.innerHTML = ''; // Clear previous results
        if (results.length === 0) {
            searchResultsDiv.innerHTML = '<p style="color: var(--grey-text);">No results found.</p>';
            return;
        }
        results.forEach(show => {
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';
            resultItem.innerHTML = `<h4>${show.name}</h4>`; // Display show name
            resultItem.addEventListener('click', () => {
                // Set current show details and save to local storage
                currentTMDBShowId = show.id;
                currentTMDBShowName = show.name;
                localStorage.setItem(LAST_SHOW_ID_KEY, currentTMDBShowId);
                localStorage.setItem(LAST_SHOW_NAME_KEY, currentTMDBShowName); // Use corrected key
                searchResultsDiv.style.display = 'none'; // Hide search results
                showSearchInput.value = ''; // Clear search input
                fetchEpisodeData(); // Load data for the newly selected show
            });
            searchResultsDiv.appendChild(resultItem);
        });
    }

    // Event listeners for search input and button
    searchShowBtn.addEventListener('click', () => searchShows(showSearchInput.value.trim()));
    showSearchInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') searchShowBtn.click(); // Trigger search on Enter key
    });

    // --- Initial Application Load ---

    /**
     * Initializes the application when the DOM is fully loaded.
     * Retrieves last active show and server from local storage or sets defaults.
     * Then fetches episode data for the selected show.
     */
    document.addEventListener('DOMContentLoaded', () => {
        const storedShowId = localStorage.getItem(LAST_SHOW_ID_KEY);
        // FIX: Read from the corrected LAST_SHOW_NAME_KEY
        const storedShowName = localStorage.getItem(LAST_SHOW_NAME_KEY); 
        const storedServer = localStorage.getItem(LAST_SERVER_KEY);
        const storedAggregator = localStorage.getItem(LAST_AGGREGATOR_KEY);

        if (storedShowId && storedShowName) {
            currentTMDBShowId = parseInt(storedShowId);
            currentTMDBShowName = storedShowName;
        } else {
            // Default to Prison Break if no last active show is stored
            currentTMDBShowId = 2288;
            currentTMDBShowName = "Prison Break";
        }

        if (storedServer) {
            currentServer = storedServer;
        } else {
            // Default to Rivestream for ad-free experience if no server is stored
            currentServer = "rivestream";
        }

        // Aggregator is now always 32 for Rivestream in the UI/logic.
        // This ensures consistency even if an old aggregator value was stored.
        if (currentServer === "rivestream") {
            currentRivestreamAggregator = "32";
        } else {
            // Keep default for other servers, though it won't be used by them.
            currentRivestreamAggregator = "32"; 
        }

        fetchEpisodeData(); // Start by fetching episode data for the determined show
    });
</script>

</body>
</html>
