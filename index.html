<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My TV Shows</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* Existing CSS */
        :root {
            --bg-dark-charcoal: #1A202C;
            --bg-medium-charcoal: #2D3748;
            --bg-light-charcoal: #4A5568;
            --blue-primary: #4299E1;
            --blue-active-border: #3182CE;
            --blue-highlight-bg: rgba(66, 153, 225, 0.2);
            --blue-watched: #63B3ED;
            --blue-to-cyan-glow: rgba(0, 191, 255, 1.0);
            --red-primary: #E53E3E;
            --white-off: #E2E8F0;
            --grey-text: #A0AEC0;
            --shadow-dark: rgba(0, 0, 0, 0.6);
            --input-focus-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
            --button-glow-light: 0 0 8px rgba(66, 153, 225, 0.8);
            --border-radius-main: 12px;
            --border-radius-small: 8px;
            --transition-speed: 0.3s;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-dark-charcoal);
            color: var(--white-off);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            line-height: 1.6;
            overflow-x: hidden;
        }

        header {
            background-color: var(--bg-medium-charcoal);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }

        .header-left {
            display: flex;
            align-items: center;
        }

        .logo {
            font-family: 'Open Sans', sans-serif;
            font-size: 1.8em;
            font-weight: 700;
            color: var(--blue-primary);
            margin-right: 20px;
            text-decoration: none;
        }

        nav a {
            color: var(--white-off);
            text-decoration: none;
            margin: 0 15px;
            font-weight: 500;
            transition: color var(--transition-speed) ease;
        }

        nav a:hover {
            color: var(--blue-primary);
        }

        .user-info {
            display: flex;
            align-items: center;
        }

        #loggedInUser {
            background-color: rgba(66, 153, 225, 0.1);
            color: var(--blue-primary);
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            font-weight: 500;
            margin-right: 15px;
            display: none; /* Hidden by default, shown by JS */
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        #loggedInUser.visible {
            display: block;
            opacity: 1;
        }

        .auth-buttons .action-button {
            background-color: var(--blue-primary);
            color: var(--white-off);
            padding: 10px 18px;
            border-radius: var(--border-radius-small);
            text-decoration: none;
            font-weight: 600;
            transition: background-color var(--transition-speed) ease, transform 0.2s ease;
            margin-left: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            display: inline-block; /* Ensure they are side-by-side */
            border: none; /* Make buttons look consistent */
            cursor: pointer;
        }

        .auth-buttons .action-button:hover {
            background-color: var(--blue-active-border);
            transform: translateY(-1px);
        }

        .auth-buttons .action-button:active {
            transform: translateY(0);
        }

        #logoutBtn {
            background-color: var(--red-primary);
        }

        #logoutBtn:hover {
            background-color: #C53030; /* Darker red */
        }

        main {
            flex-grow: 1;
            padding: 30px 20px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .shows-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .show-card {
            background-color: var(--bg-medium-charcoal);
            border-radius: var(--border-radius-main);
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            transition: transform var(--transition-speed) ease, box-shadow var(--transition-speed) ease;
            position: relative;
        }

        .show-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5), 0 0 15px var(--blue-to-cyan-glow);
        }

        .show-card img {
            width: 100%;
            height: 200px; /* Fixed height for consistency */
            object-fit: cover;
            border-bottom: 1px solid var(--bg-light-charcoal);
        }

        .show-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            flex-grow: 1;
        }

        .show-title {
            font-size: 1.6em;
            font-weight: 700;
            color: var(--blue-primary);
            margin-top: 0;
            margin-bottom: 10px;
            text-align: center;
        }

        .show-info {
            font-size: 0.95em;
            color: var(--grey-text);
            margin-bottom: 15px;
            flex-grow: 1; /* Pushes watch section to bottom */
        }

        .watch-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--bg-light-charcoal);
        }

        .watch-section button {
            background-color: var(--blue-primary);
            color: var(--white-off);
            border: none;
            padding: 10px 15px;
            border-radius: var(--border-radius-small);
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: background-color var(--transition-speed) ease, transform 0.2s ease;
        }

        .watch-section button:hover {
            background-color: var(--blue-active-border);
            transform: translateY(-1px);
        }

        .watch-section button:active {
            transform: translateY(0);
        }

        .watch-section span {
            font-size: 1em;
            font-weight: 500;
            color: var(--white-off);
        }

        .watched-label {
            background-color: var(--blue-watched);
            color: var(--white-off);
            font-size: 0.8em;
            font-weight: 700;
            padding: 5px 10px;
            border-radius: 5px;
            position: absolute;
            top: 15px;
            right: 15px;
            display: none; /* Hidden by default */
        }

        .watched-label.active {
            display: block;
        }

        .load-more-container {
            text-align: center;
            margin-top: 30px;
        }

        #loadMoreBtn {
            background-color: var(--bg-medium-charcoal);
            color: var(--blue-primary);
            padding: 12px 25px;
            border-radius: var(--border-radius-small);
            font-size: 1.05em;
            font-weight: 600;
            border: 1px solid var(--blue-primary);
            cursor: pointer;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }

        #loadMoreBtn:hover {
            background-color: var(--blue-primary);
            color: var(--white-off);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .shows-grid {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            }
            .header-left {
                flex-direction: column;
                align-items: flex-start;
            }
            nav {
                margin-top: 10px;
            }
            nav a {
                margin: 0 8px;
                font-size: 0.9em;
            }
            .logo {
                margin-bottom: 10px;
            }
        }

        @media (max-width: 480px) {
            .shows-grid {
                grid-template-columns: 1fr;
            }
            .login-container {
                padding: 25px;
            }
            h2 {
                font-size: 1.8em;
            }
            .auth-button {
                padding: 12px 15px;
                font-size: 1em;
            }
        }
        #clearDataBtn {
            background-color: #555;
        }
        #clearDataBtn:hover {
            background-color: #777;
        }
    </style>
</head>
<body>
    <header>
        <div class="header-left">
            <a href="#" class="logo">My TV Shows</a>
            <nav>
                <a href="#">Home</a>
                <a href="#">Explore</a>
                <a href="#">My List</a>
            </nav>
        </div>
        <div class="user-info">
            <span id="loggedInUser">Not logged in</span>
            <div class="auth-buttons">
                <a href="login.html" id="loginBtn" class="action-button">Login</a>
                <a href="login.html?mode=signup" id="signupBtn" class="action-button">Sign Up</a>
                <button id="logoutBtn" class="action-button" style="display: none;">Logout</button>
                <button id="clearDataBtn" class="action-button" style="display: none;">Clear Local Data</button>
            </div>
        </div>
    </header>

    <main>
        <ul id="showsGrid" class="shows-grid">
            <!-- Show cards will be dynamically inserted here -->
        </ul>
        <div class="load-more-container">
            <button id="loadMoreBtn">Load More</button>
        </div>
    </main>

    <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInWithCustomToken, signInAnonymously, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, getDoc, setDoc, collection, query, where, onSnapshot, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    let app;
    let auth;
    let db;
    let firebaseInitialized = false;
    let isAuthReady = false;
    let userId = null;

    // Data caches
    let watchedData = {}; // Stores { showId: true/false }
    let progressData = {}; // Stores { showId: { season: currentSeason, episode: currentEpisode } }
    let lastWatchedData = {}; // Stores { showId: timestamp }

    const SHOWS_PER_LOAD = 6;
    let loadedShowsCount = 0;
    let allShows = []; // To store all fetched show data

    const showsGrid = document.getElementById('showsGrid');
    const loadMoreBtn = document.getElementById('loadMoreBtn');
    const loggedInUserSpan = document.getElementById('loggedInUser');
    const loginBtn = document.getElementById('loginBtn');
    const signupBtn = document.getElementById('signupBtn');
    const logoutBtn = document.getElementById('logoutBtn');
    const clearDataBtn = document.getElementById('clearDataBtn');


    // --- Firebase Initialization and Auth State Management ---
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            // Check if __firebase_config is available (provided by the platform)
            if (typeof __firebase_config !== 'undefined') {
                const firebaseConfig = __firebase_config; // Use platform-provided config
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                firebaseInitialized = true;
                console.log("Firebase initialized from platform config.");
            } else {
                console.log("No __firebase_config found. Attempting local mode initialization with hardcoded config.");
                // Fallback for local development or if platform config is not available
                // IMPORTANT: These values are specific to your Firebase project.
                // You can get these from your Firebase console -> Project settings -> Your apps
                const localFirebaseConfig = {
                    apiKey: "AIzaSyCljYuy1I3tlQWTevjS-_ZqJTU7FB7R90o",
                    authDomain: "my-tv-shows-87d08.firebaseapp.com",
                    projectId: "my-tv-shows-87d08",
                    storageBucket: "my-tv-shows-87d08.firebasestorage.app",
                    messagingSenderId: "397623803820",
                    appId: "1:397623803820:web:05dc3c56630f73cf93c409",
                    measurementId: "G-CSEYYMHH5L"
                };
                // Only initialize if an API key is provided and projectId is not placeholder
                if (localFirebaseConfig.apiKey && localFirebaseConfig.projectId && localFirebaseConfig.projectId !== "YOUR_PROJECT_ID") { 
                    app = initializeApp(localFirebaseConfig);
                    auth = getAuth(app);
                    db = getFirestore(app);
                    firebaseInitialized = true;
                    console.log("Firebase initialized from local config (using provided details).");
                } else {
                    console.warn("Local Firebase config is incomplete or uses placeholder values. Running in local-only mode.");
                    firebaseInitialized = false;
                    isAuthReady = true; // Mark auth ready even without Firebase
                    userId = null; // No user ID in local-only mode
                    loggedInUserSpan.textContent = 'Running in local mode (ID: anonymous)';
                    loggedInUserSpan.classList.add('visible');
                    loginBtn.style.display = 'inline-block';
                    signupBtn.style.display = 'inline-block';
                    logoutBtn.style.display = 'none';
                    clearDataBtn.style.display = 'inline-block'; // Allow clearing local data
                    
                    // Load data from local storage immediately if Firebase not initialized
                    watchedData = getWatchedLocal();
                    progressData = getProgressLocal();
                    lastWatchedData = getLastWatchedLocal();
                    await fetchAndRenderShows(); // Still fetch shows for display
                    return; // Exit here as Firebase is not functional
                }
            }
            
            // Authentication state listener - this is the core of data sync
            // It handles both initial load and subsequent changes (login/logout)
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    loggedInUserSpan.textContent = `Logged in as: ${user.email || 'Anonymous'} (ID: ${userId})`;
                    loggedInUserSpan.classList.add('visible');
                    loginBtn.style.display = 'none';
                    signupBtn.style.display = 'none';
                    logoutBtn.style.display = 'inline-block';
                    clearDataBtn.style.display = 'inline-block'; // Show clear data button when logged in
                    console.log("User logged in. userId:", userId);

                    // Set up Firestore listeners *after* user is authenticated
                    setupFirestoreListeners();

                    // Migrate local data to Firestore BEFORE loading Firestore data/UI
                    await migrateLocalDataToFirestore();

                    // Load data from Firestore after listeners are set up and user is authenticated
                    // This will trigger snapshot listeners if data exists.
                    watchedData = await getFirestoreDoc('watched') || {};
                    progressData = await getFirestoreDoc('progress') || {};
                    lastWatchedData = await getFirestoreDoc('lastWatched') || {};
                    console.log("Initial data loaded from Firestore after login.");
                } else {
                    // User is logged out or is anonymous (if anonymous sign-in was used)
                    userId = null;
                    loggedInUserSpan.classList.remove('visible');
                    loginBtn.style.display = 'inline-block';
                    signupBtn.style.display = 'inline-block';
                    logoutBtn.style.display = 'none';
                    clearDataBtn.style.display = 'inline-block'; // Allow clearing local data when logged out too
                    console.log("User logged out or is not authenticated. Falling back to local storage.");

                    // When logged out, switch to using local storage immediately
                    watchedData = getWatchedLocal();
                    progressData = getProgressLocal();
                    lastWatchedData = getLastWatchedLocal();
                }
                isAuthReady = true; // Auth state check complete
                console.log(`Auth state ready. userId: ${userId}, isAuthReady: ${isAuthReady}, firebaseInitialized: ${firebaseInitialized}`);

                // Re-render UI based on the current data source (Firestore or Local)
                await fetchAndRenderShows(); // Fetch and render shows after auth state is ready
            });

            // Attempt initial sign-in if no user is currently authenticated
            if (!auth.currentUser) {
                try {
                    // Try to sign in with a custom token if provided by the environment
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                        console.log("Attempted sign-in with custom token.");
                    } else {
                        // If no custom token, or if custom token is invalid/empty, try anonymous
                        await signInAnonymously(auth);
                        console.log("Attempted anonymous sign-in.");
                    }
                } catch (initialSignInError) {
                    console.error("Error during initial sign-in (anonymous or custom token):", initialSignInError.code, initialSignInError.message);
                    // Specific error handling for common auth issues during initial sign-in
                    if (initialSignInError.code === 'auth/custom-token-mismatch' || initialSignInError.code === 'auth/invalid-custom-token') {
                        showCustomModal("There was an issue with the provided custom token. Attempting anonymous login. Please check your token or Firebase setup if this persists.", "alert");
                        try {
                            await signInAnonymously(auth);
                            console.log("Fell back to anonymous sign-in after custom token failure.");
                        } catch (anonFallbackError) {
                            console.error("Error during anonymous fallback sign-in:", anonFallbackError.code, anonFallbackError.message);
                            if (anonFallbackError.code === 'auth/operation-not-allowed' || anonFallbackError.code === 'auth/admin-restricted-operation') {
                                showCustomModal("Anonymous authentication is not enabled in your Firebase project. Please enable it in Firebase console (Authentication -> Sign-in method -> Anonymous). Running in local-only mode.", "alert");
                            } else {
                                showCustomModal(`Authentication setup failed: ${anonFallbackError.message}. Running in local-only mode.`, "alert");
                            }
                            // Force local mode if all authentication attempts fail
                            firebaseInitialized = false; 
                            isAuthReady = true; 
                            userId = null; 
                            loggedInUserSpan.textContent = 'Running in local mode (ID: anonymous)';
                            loggedInUserSpan.classList.add('visible');
                            loginBtn.style.display = 'inline-block';
                            signupBtn.style.display = 'inline-block';
                            logoutBtn.style.display = 'none';
                            clearDataBtn.style.display = 'inline-block';
                            watchedData = getWatchedLocal();
                            progressData = getProgressLocal();
                            lastWatchedData = getLastWatchedLocal();
                            await fetchAndRenderShows();
                        }
                    } else if (initialSignInError.code === 'auth/operation-not-allowed' || initialSignInError.code === 'auth/admin-restricted-operation') {
                         showCustomModal("Anonymous authentication is not enabled in your Firebase project. Please enable it in Firebase console (Authentication -> Sign-in method -> Anonymous). Running in local-only mode.", "alert");
                         firebaseInitialized = false; 
                         isAuthReady = true; 
                         userId = null;
                         loggedInUserSpan.textContent = 'Running in local mode (ID: anonymous)';
                         loggedInUserSpan.classList.add('visible');
                         loginBtn.style.display = 'inline-block';
                         signupBtn.style.display = 'inline-block';
                         logoutBtn.style.display = 'none';
                         clearDataBtn.style.display = 'inline-block';
                         watchedData = getWatchedLocal();
                         progressData = getProgressLocal();
                         lastWatchedData = getLastWatchedLocal();
                         await fetchAndRenderShows();
                    } else {
                        showCustomModal(`Initial authentication failed: ${initialSignInError.message}. Running in local-only mode.`, "alert");
                        firebaseInitialized = false;
                        isAuthReady = true; 
                        userId = null;
                        loggedInUserSpan.textContent = 'Running in local mode (ID: anonymous)';
                        loggedInUserSpan.classList.add('visible');
                        loginBtn.style.display = 'inline-block';
                        signupBtn.style.display = 'inline-block';
                        logoutBtn.style.display = 'none';
                        clearDataBtn.style.display = 'inline-block';
                        watchedData = getWatchedLocal();
                        progressData = getProgressLocal();
                        lastWatchedData = getLastWatchedLocal();
                        await fetchAndRenderShows();
                    }
                }
            } else {
                // If currentUser already exists (e.g., persistent session), ensure UI is updated
                userId = auth.currentUser.uid;
                loggedInUserSpan.textContent = `Logged in as: ${auth.currentUser.email || 'Anonymous'} (ID: ${userId})`;
                loggedInUserSpan.classList.add('visible');
                loginBtn.style.display = 'none';
                signupBtn.style.display = 'none';
                logoutBtn.style.display = 'inline-block';
                clearDataBtn.style.display = 'inline-block';
                console.log("Firebase already authenticated. userId:", userId);
                isAuthReady = true;
                setupFirestoreListeners(); // Setup listeners for existing user
                // Data will be loaded via onAuthStateChanged listener already, or directly if needed
                watchedData = await getFirestoreDoc('watched') || {};
                progressData = await getFirestoreDoc('progress') || {};
                lastWatchedData = await getFirestoreDoc('lastWatched') || {};
                await fetchAndRenderShows();
            }

        } catch (e) {
            console.error("Failed to initialize Firebase outer block:", e);
            firebaseInitialized = false;
            isAuthReady = true;
            userId = null;
            loggedInUserSpan.textContent = 'Running in local mode (ID: anonymous)';
            loggedInUserSpan.classList.add('visible');
            loginBtn.style.display = 'inline-block';
            signupBtn.style.display = 'inline-block';
            logoutBtn.style.display = 'none';
            clearDataBtn.style.display = 'inline-block';
            watchedData = getWatchedLocal();
            progressData = getProgressLocal();
            lastWatchedData = getLastWatchedLocal();
            await fetchAndRenderShows();
        }
    });

    // --- Custom Modal Function ---
    function showCustomModal(message, type = 'alert', onConfirm = null) {
        const modalOverlay = document.getElementById('customModalOverlay');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const modalCloseBtn = document.getElementById('modalCloseBtn');

        // Reset all buttons and click handlers
        modalConfirmBtn.style.display = 'none';
        modalCancelBtn.style.display = 'none';
        modalCloseBtn.style.display = 'none';
        modalConfirmBtn.onclick = null;
        modalCancelBtn.onclick = null;
        modalCloseBtn.onclick = null;

        modalMessage.textContent = message;

        if (type === 'confirm') {
            modalTitle.textContent = 'Confirm Action';
            modalConfirmBtn.textContent = 'Confirm';
            modalConfirmBtn.style.display = 'inline-block';
            modalCancelBtn.textContent = 'Cancel';
            modalCancelBtn.style.display = 'inline-block';

            modalConfirmBtn.onclick = () => {
                modalOverlay.style.display = 'none';
                if (onConfirm) onConfirm(true);
            };
            modalCancelBtn.onclick = () => {
                modalOverlay.style.display = 'none';
                if (onConfirm) onConfirm(false);
            };
        } else { // 'alert' type
            modalTitle.textContent = 'Notification';
            modalCloseBtn.textContent = 'Close';
            modalCloseBtn.style.display = 'inline-block';
            modalCloseBtn.onclick = () => {
                modalOverlay.style.display = 'none';
            };
        }
        modalOverlay.style.display = 'flex'; // Show modal
    }


    // --- Local Storage Functions ---
    function getWatchedLocal() {
        try {
            return JSON.parse(localStorage.getItem('watchedShows')) || {};
        } catch (e) {
            console.error("Error parsing local watched data:", e);
            return {};
        }
    }

    function setWatchedLocal(data) {
        try {
            localStorage.setItem('watchedShows', JSON.stringify(data));
        } catch (e) {
            console.error("Error saving local watched data:", e);
        }
    }

    function getProgressLocal() {
        try {
            return JSON.parse(localStorage.getItem('progressShows')) || {};
        } catch (e) {
            console.error("Error parsing local progress data:", e);
            return {};
        }
    }

    function setProgressLocal(data) {
        try {
            localStorage.setItem('progressShows', JSON.stringify(data));
        } catch (e) {
            console.error("Error saving local progress data:", e);
        }
    }

    function getLastWatchedLocal() {
        try {
            return JSON.parse(localStorage.getItem('lastWatchedShow')) || {};
        } catch (e) {
            console.error("Error parsing local last watched data:", e);
            return {};
        }
    }

    function setLastWatchedLocal(showId, season, episode, timestamp) {
        try {
            const data = { showId, season, episode, timestamp };
            localStorage.setItem('lastWatchedShow', JSON.stringify(data));
        } catch (e) {
            console.error("Error saving local last watched data:", e);
        }
    }


    // --- Firebase Data Functions ---
    async function getFirestoreDoc(collectionName) {
        if (!userId || !db || !firebaseInitialized) {
            console.warn(`Attempted to get Firestore doc '${collectionName}' without userId or db initialized or firebase not ready.`);
            return null;
        }
        // Use __app_id if available, otherwise a static ID for local development
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const docRef = doc(db, `artifacts/${appId}/users/${userId}/${collectionName}/data`);
        try {
            const docSnap = await getDoc(docRef);
            return docSnap.exists() ? JSON.parse(docSnap.data().value) : null;
        } catch (e) {
            console.error(`Error fetching Firestore doc '${collectionName}':`, e);
            return null;
        }
    }

    async function setFirestoreDoc(collectionName, data) {
        if (!userId || !db || !firebaseInitialized) {
            console.warn(`Attempted to set Firestore doc '${collectionName}' without userId or db initialized or firebase not ready.`);
            return;
        }
        // Use __app_id if available, otherwise a static ID for local development
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const docRef = doc(db, `artifacts/${appId}/users/${userId}/${collectionName}/data`);
        try {
            await setDoc(docRef, { value: JSON.stringify(data) }, { merge: true });
        } catch (e) {
            console.error(`Error setting Firestore doc '${collectionName}':`, e);
        }
    }

    // --- Wrapped Data Access Functions (to use Firestore if logged in, else Local Storage) ---
    function getWatched() {
        return (userId && isAuthReady && firebaseInitialized) ? watchedData : getWatchedLocal();
    }
    function setWatched(data) {
        if (userId && isAuthReady && firebaseInitialized && db) {
            watchedData = data; // update in-memory
            setFirestoreDoc('watched', data);
        } else {
            setWatchedLocal(data);
        }
        renderShows(allShows); // Re-render to reflect changes
    }
    function getProgress() {
        return (userId && isAuthReady && firebaseInitialized) ? progressData : getProgressLocal();
    }
    function setProgress(data) {
        if (userId && isAuthReady && firebaseInitialized && db) {
            progressData = data; // update in-memory
            setFirestoreDoc('progress', data);
        } else {
            setProgressLocal(data);
        }
        renderShows(allShows); // Re-render to reflect changes
    }
    function getLastWatched() {
        return (userId && isAuthReady && firebaseInitialized) ? lastWatchedData : getLastWatchedLocal();
    }
    function setLastWatched(showId, season, episode, timestamp) {
        if (userId && isAuthReady && firebaseInitialized && db) {
            lastWatchedData = { showId, season, episode, timestamp }; // update in-memory
            setFirestoreDoc('lastWatched', { showId, season, episode, timestamp });
        } else {
            setLastWatchedLocal(showId, season, episode, timestamp);
        }
        renderShows(allShows); // Re-render to reflect changes
    }


    // --- Firestore Listeners: Always update UI on change ---
    function setupFirestoreListeners() {
        if (!db || !userId || !firebaseInitialized) {
            console.warn("Firestore listeners not set up: DB, userId, or firebase not initialized.");
            return;
        }

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const watchedDocRef = doc(db, `artifacts/${appId}/users/${userId}/watched/data`);
        const progressDocRef = doc(db, `artifacts/${appId}/users/${userId}/progress/data`);
        const lastWatchedDocRef = doc(db, `artifacts/${appId}/users/${userId}/lastWatched/data`);

        onSnapshot(watchedDocRef, (docSnap) => {
            watchedData = docSnap.exists() ? JSON.parse(docSnap.data().value) : {};
            console.log("Watched data updated by Firestore snapshot:", watchedData);
            renderShows(allShows); // Re-render UI
        }, (error) => console.error("Error watching watched data:", error));

        onSnapshot(progressDocRef, (docSnap) => {
            progressData = docSnap.exists() ? JSON.parse(docSnap.data().value) : {};
            console.log("Progress data updated by Firestore snapshot:", progressData);
            renderShows(allShows); // Re-render UI
        }, (error) => console.error("Error watching progress data:", error));

        onSnapshot(lastWatchedDocRef, (docSnap) => {
            lastWatchedData = docSnap.exists() ? JSON.parse(docSnap.data().value) : {};
            console.log("Last watched data updated by Firestore snapshot:", lastWatchedData);
            renderShows(allShows); // Re-render UI
        }, (error) => console.error("Error watching last watched data:", error));
    }


    // --- Migrate Local Data to Firestore on Login (Merge Strategy) ---
    async function migrateLocalDataToFirestore() {
        if (!isAuthReady || !userId || !db || !firebaseInitialized) return;
        
        console.log("Attempting to migrate local data to Firestore...");

        const localWatched = getWatchedLocal();
        const localProgress = getProgressLocal();
        const localLastWatched = getLastWatchedLocal();

        // Merge watched data
        if (Object.keys(localWatched).length > 0) {
            try {
                const firestoreWatched = await getFirestoreDoc('watched') || {};
                const mergedWatched = { ...firestoreWatched };
                for (const showId in localWatched) {
                    if (localWatched[showId]) { // If local says watched
                         mergedWatched[showId] = true;
                    }
                }
                await setFirestoreDoc('watched', mergedWatched);
                localStorage.removeItem('watchedShows');
                console.log("Watched data migrated.");
            } catch (error) {
                console.error("Error migrating watched data:", error);
            }
        }

        // Merge progress data (prefer higher progress)
        if (Object.keys(localProgress).length > 0) {
            try {
                const firestoreProgress = await getFirestoreDoc('progress') || {};
                const mergedProgress = { ...firestoreProgress };
                for (const showId in localProgress) {
                    if (!mergedProgress[showId]) {
                        mergedProgress[showId] = {};
                    }
                    // For each show, iterate through seasons/episodes to merge progress
                    const localShowProgress = localProgress[showId];
                    const firestoreShowProgress = firestoreProgress[showId] || {};

                    for (const season in localShowProgress) {
                        if (!mergedProgress[showId][season]) {
                            mergedProgress[showId][season] = {};
                        }
                        const localSeasonProgress = localShowProgress[season];
                        const firestoreSeasonProgress = firestoreShowProgress[season] || {};

                        for (const episode in localSeasonProgress) {
                            const localTime = localSeasonProgress[episode];
                            const firestoreTime = firestoreSeasonProgress[episode] || 0;
                            mergedProgress[showId][season][episode] = Math.max(localTime, firestoreTime);
                        }
                    }
                }
                await setFirestoreDoc('progress', mergedProgress);
                localStorage.removeItem('progressShows');
                console.log("Progress data migrated.");
            } catch (error) {
                console.error("Error migrating progress data:", error);
            }
        }

        // Merge last watched data (prefer most recent timestamp)
        if (Object.keys(localLastWatched).length > 0 && localLastWatched.showId) {
            try {
                const firestoreLastWatched = await getFirestoreDoc('lastWatched') || {};
                let shouldUpdateLastWatched = true;

                if (firestoreLastWatched && firestoreLastWatched.timestamp) {
                    // Compare timestamps. If local is newer, update.
                    if (localLastWatched.timestamp <= firestoreLastWatched.timestamp) {
                        shouldUpdateLastWatched = false;
                    }
                }

                if (shouldUpdateLastWatched) {
                    await setFirestoreDoc('lastWatched', localLastWatched);
                    localStorage.removeItem('lastWatchedShow');
                    console.log("Last watched data migrated.");
                } else {
                    console.log("Firestore last watched data was more recent, no migration needed.");
                }
            } catch (error) {
                console.error("Error migrating last watched data:", error);
            }
        }
        console.log("Local data migration process completed.");
    }

    // --- Logout Functionality ---
    logoutBtn.addEventListener('click', async () => {
        if (auth) {
            try {
                await signOut(auth);
                // The onAuthStateChanged listener will handle UI updates and local storage fallback
                showCustomModal('You have been logged out.', 'alert');
                console.log("User logged out successfully.");
            } catch (error) {
                console.error("Error logging out:", error);
                showCustomModal('Error logging out. Please try again.', 'alert');
            }
        } else {
            showCustomModal('Not logged in.', 'alert');
        }
    });

    // --- Clear Data Functionality ---
    clearDataBtn.addEventListener('click', function() {
        showCustomModal('Are you sure you want to clear all data (watched status, progress, and last watched)? This cannot be undone.', 'confirm', async (response) => {
            if (response) {
                if (userId && db && firebaseInitialized) {
                    try {
                        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                        await setDoc(doc(db, `artifacts/${appId}/users/${userId}/watched/data`), { value: JSON.stringify({}) });
                        await setDoc(doc(db, `artifacts/${appId}/users/${userId}/progress/data`), { value: JSON.stringify({}) });
                        await setDoc(doc(db, `artifacts/${appId}/users/${userId}/lastWatched/data`), { value: JSON.stringify({}) });
                        console.log("Firestore data cleared for user:", userId);
                        showCustomModal('All data (local and cloud) has been cleared.', 'alert');
                    } catch (error) {
                        console.error("Error clearing Firestore data:", error);
                        showCustomModal('Error clearing cloud data. Please try again.', 'alert');
                    }
                } else {
                    showCustomModal('No user logged in to clear cloud data. Clearing local data only.', 'alert');
                }

                // Always clear local storage, regardless of Firebase status
                localStorage.removeItem('watchedShows');
                localStorage.removeItem('progressShows');
                localStorage.removeItem('lastWatchedShow');
                console.log("Local storage data cleared.");

                // Reset in-memory data caches and re-render UI
                watchedData = {};
                progressData = {};
                lastWatchedData = {};
                loadedShowsCount = 0; // Reset loaded count to reload from start
                await fetchAndRenderShows(); // Re-fetch and re-render shows with cleared data
            }
        });
    });

    // --- Show Data Simulation and Rendering ---
    // Simulate fetching popular TV show data (replace with actual API calls if desired)
    async function fetchPopularShows() {
        // This is mock data for demonstration. In a real app, you'd fetch from an API like TMDB.
        return [
            {
                id: 'americanDad',
                title: 'American Dad!',
                poster: 'https://image.tmdb.org/t/p/w300/yK9W8L3c9oW6Uv9y1xY8J7G9h9S.jpg',
                description: 'The everyday life of a family is turned upside down by a talking goldfish and an alien.',
                seasons: 20 // Approx seasons
            },
            {
                id: 'familyGuy',
                title: 'Family Guy',
                poster: 'https://image.tmdb.org/t/p/w300/aFGQz33zHq7n0kL6H5UuBw09kC8.jpg',
                description: 'The adventures of a dysfunctional family living in Quahog, Rhode Island.',
                seasons: 22
            },
            {
                id: 'theSimpsons',
                title: 'The Simpsons',
                poster: 'https://image.tmdb.org/t/p/w300/nmc9K2w236A9tU5r2f0I7sWfC4M.jpg',
                description: 'The longest-running animated show in television history, chronicling the life of the Simpson family.',
                seasons: 36
            },
            {
                id: 'southPark',
                title: 'South Park',
                poster: 'https://image.tmdb.org/t/p/w300/gO8Qo7dG6fB232bQGv9WwB2sUjP.jpg',
                description: 'Follows the misadventures of four foul-mouthed grade-schoolers in the dysfunctional town of South Park, Colorado.',
                seasons: 26
            },
            {
                id: 'futurama',
                title: 'Futurama',
                poster: 'https://image.tmdb.org/t/p/w300/jQjT56S9X77qC42GjWw6uW2M0Wb.jpg',
                description: 'Fry, a pizza delivery boy, is accidentally frozen in 1999 and thawed out in the year 3000.',
                seasons: 11
            },
            {
                id: 'rickAndMorty',
                title: 'Rick and Morty',
                poster: 'https://image.tmdb.org/t/p/w300/cvhNjqA1B4R79zT5b7Kj7j8cT8B.jpg',
                description: 'An animated series that follows the exploits of a super scientist and his not-so-bright grandson.',
                seasons: 7
            },
            {
                id: 'bojackHorseman',
                title: 'BoJack Horseman',
                poster: 'https://image.tmdb.org/t/p/w300/kYg3rO55r9f7n4QxYnE5f8p7W0W.jpg',
                description: 'BoJack Horseman, a washed-up 90s sitcom star, tries to navigate his way through life and a spiraling depression.',
                seasons: 6
            },
            {
                id: 'archer',
                title: 'Archer',
                poster: 'https://image.tmdb.org/t/p/w300/oJmG373Y7l9P4b6XQ1N1zS00QjF.jpg',
                description: 'The suave, narcissistic spy Sterling Archer and his dysfunctional colleagues at the ISIS espionage agency.',
                seasons: 14
            },
             {
                id: 'disenchantment',
                title: 'Disenchantment',
                poster: 'https://image.tmdb.org/t/p/w300/w062e5nN6m2GgCj3oJm3jR7B3XQ.jpg',
                description: 'Princess Bean, an alcoholic princess, her feisty elf companion Elfo, and her personal demon Luci explore Dreamland.',
                seasons: 5
            },
            {
                id: 'bigMouth',
                title: 'Big Mouth',
                poster: 'https://image.tmdb.org/t/p/w300/a3W2m73W7vBkw34l3lUoE5w6s1w.jpg',
                description: 'Teenage friends are tormented by the horrors of puberty in this adult animated comedy.',
                seasons: 7
            }
        ];
    }


    async function fetchAndRenderShows() {
        allShows = await fetchPopularShows();
        loadedShowsCount = 0; // Reset for a fresh load
        renderShows(allShows);
    }


    function renderShows(shows) {
        showsGrid.innerHTML = ''; // Clear existing shows
        const currentWatched = getWatched();
        const currentProgress = getProgress();
        const currentLastWatched = getLastWatched();

        const showsToRender = shows.slice(0, loadedShowsCount + SHOWS_PER_LOAD);
        loadedShowsCount = showsToRender.length; // Update count of actually rendered shows

        showsToRender.forEach(show => {
            const isShowWatched = currentWatched[show.id];
            const showProgress = currentProgress[show.id];
            const showLastWatched = currentLastWatched.showId === show.id ? currentLastWatched : null;

            let progressText = 'Not Started';
            let watchButtonText = 'Start Watching';
            let watchAction = `openShowDetails('${show.id}')`; // Default action: open details page

            if (isShowWatched) {
                progressText = 'Watched';
                watchButtonText = 'Re-watch';
            } else if (showProgress && Object.keys(showProgress).length > 0) {
                // Find the latest episode in progress
                let latestSeason = '1';
                let latestEpisode = '1';
                let latestTimestamp = 0;

                for (const season in showProgress) {
                    for (const episode in showProgress[season]) {
                        if (showProgress[season][episode] > latestTimestamp) {
                            latestTimestamp = showProgress[season][episode];
                            latestSeason = season;
                            latestEpisode = episode;
                        }
                    }
                }
                progressText = `S${latestSeason} E${latestEpisode} (${Math.floor(latestTimestamp / 60)} min)`;
                watchButtonText = 'Continue Watching';
                watchAction = `openShowDetails('${show.id}', '${latestSeason}', '${latestEpisode}', ${Math.floor(latestTimestamp)})`;
            } else if (showLastWatched && showLastWatched.timestamp) {
                 // Fallback if progressData is empty but lastWatchedData exists (e.g., just started)
                progressText = `S${showLastWatched.season} E${showLastWatched.episode}`;
                watchButtonText = 'Continue Watching';
                watchAction = `openShowDetails('${show.id}', '${showLastWatched.season}', '${showLastWatched.episode}', ${Math.floor(showLastWatched.timestamp)})`;
            }


            const showCard = document.createElement('li');
            showCard.classList.add('show-card');
            showCard.dataset.showId = show.id;

            showCard.innerHTML = `
                <span class="watched-label ${isShowWatched ? 'active' : ''}">WATCHED</span>
                <img src="${show.poster}" alt="${show.title} Poster" onerror="this.onerror=null; this.src='https://placehold.co/300x200/2D3748/A0AEC0?text=NO+IMAGE';">
                <div class="show-content">
                    <h3 class="show-title">${show.title}</h3>
                    <p class="show-info">${show.description}</p>
                    <div class="watch-section">
                        <span>Progress: ${progressText}</span>
                        <button onclick="${watchAction}">${watchButtonText}</button>
                    </div>
                </div>
            `;
            showsGrid.appendChild(showCard);
        });

        // Update load more button visibility
        if (loadedShowsCount < allShows.length) {
            loadMoreBtn.style.display = 'block';
        } else {
            loadMoreBtn.style.display = 'none';
        }
    }

    // Function to handle opening show details or playing an episode
    window.openShowDetails = function(showId, season = '1', episode = '1', startTime = 0) {
        // In a real application, this would redirect to a dedicated show/episode page.
        // For this example, we'll just log and simulate.
        console.log(`Opening Show: ${showId}, Season: ${season}, Episode: ${episode}, Start Time: ${startTime}s`);
        
        // Simulate "watching" by updating progress and last watched
        let currentProgress = getProgress();
        if (!currentProgress[showId]) currentProgress[showId] = {};
        if (!currentProgress[showId][season]) currentProgress[showId][season] = {};
        currentProgress[showId][season][episode] = startTime + 30; // Simulate 30 seconds of watching
        
        setProgress(currentProgress);
        setLastWatched(showId, season, episode, Date.now()); // Update last watched timestamp
        
        // Optionally mark as watched if duration passes a threshold (e.g., 10 minutes)
        if (currentProgress[showId][season][episode] >= 600) { // 10 minutes
            let currentWatched = getWatched();
            currentWatched[showId] = true;
            setWatched(currentWatched);
        }

        // Re-render the cards to reflect the updated progress/watched status
        renderShows(allShows); 
        showCustomModal(`Simulating playback for ${showId}, S${season} E${episode}. Progress updated!`, 'alert');
    };

    loadMoreBtn.addEventListener('click', () => {
        renderShows(allShows);
    });

    // Initial fetch and render of shows when auth state is ready
    // This is handled by onAuthStateChanged now, which calls fetchAndRenderShows.
    // If Firebase initialization fails and we fall back to local mode, fetchAndRenderShows is called directly.

    </script>
</body>
</html>
