<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My TV Shows</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark-charcoal: #1A202C;
            --bg-medium-charcoal: #2D3748;
            --bg-light-charcoal: #4A5568;
            --blue-primary: #4299E1;
            --blue-active-border: #3182CE;
            --blue-highlight-bg: rgba(66, 153, 225, 0.2);
            --blue-watched: #63B3ED;
            --blue-to-cyan-glow: rgba(0, 191, 255, 1.0);
            --red-primary: #E53E3E;
            --white-off: #E2E8F0;
            --white-icons: rgba(255, 255, 255, 0.8);
            --grey-text: #A0AEC0;
            --grey-buttons: #888;
            --grey-border: #4A5568;
            --shadow-light: rgba(0, 0, 0, 0.2);
            --shadow-medium: rgba(0, 0, 0, 0.4);
            --shadow-dark: rgba(0, 0, 0, 0.6);
            --button-glow-light: 0 0 8px 4px rgba(0, 191, 255, 0.6);
            --button-glow-hover: 0 0 12px 6px rgba(0, 191, 255, 0.9);
        }

        body {
            background: var(--bg-dark-charcoal);
            font-family: 'Roboto', sans-serif;
            color: var(--white-off);
            text-align: center;
            padding: 20px;
            line-height: 1.6;
            margin: 0;
            overflow-x: hidden;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: var(--bg-medium-charcoal);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 20px var(--shadow-dark);
            border: 1px solid var(--grey-border);
            position: relative;
            overflow: hidden;
        }
        h1 {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 2.5em;
            color: var(--white-off);
            letter-spacing: 1.5px;
            margin-bottom: 24px;
            text-shadow: 2px 2px 6px var(--shadow-light);
        }
        label {
            display: block;
            margin: 10px 0 5px;
            color: var(--blue-primary);
            font-weight: 600;
            font-family: 'Open Sans', sans-serif;
            font-size: 0.95em;
        }
        .selection-row {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 25px;
            gap: 20px;
        }

        .selects-container-desktop {
            display: flex;
            gap: 20px;
            align-items: flex-end;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }

        .control-group label {
            margin: 0;
            display: inline-block;
        }

        .action-button {
            padding: 15px 30px;
            font-size: 1.1em;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 700;
            font-family: 'Open Sans', sans-serif;
            background-color: var(--blue-primary);
            color: #fff;
            min-width: 150px;
            display: flex; /* Changed to flex for internal alignment */
            align-items: center; /* Center content vertically */
            justify-content: center; /* Center content horizontally */
            gap: 8px; /* Space between icon and text */
            white-space: nowrap;
            height: fit-content;
            margin-bottom: 0;
            align-self: center;
            box-shadow: var(--button-glow-light);
            transform: translateY(0);
            transition: box-shadow 0.2s ease-in-out, transform 0.2s ease-in-out, background-color 0.2s ease-in-out, color 0.2s ease-in-out;
            text-decoration: none;
        }
        .action-button:hover, .action-button:active {
            box-shadow: var(--button-glow-hover);
            transform: translateY(-2px);
            background-color: var(--blue-primary);
            color: #fff;
        }
        /* Ensure inner elements don't block button clicks */
        .action-button i, .action-button span {
            pointer-events: none;
        }


        #playBtn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        #playBtn .fas {
            font-size: 1.2em;
        }

        #videoPlayer {
            margin-top: 35px;
            border: none;
            border-radius: 12px;
            width: 100%;
            min-height: 480px;
            height: 60vh;
            background: #000;
            box-shadow: 0 0 15px 8px var(--blue-to-cyan-glow);
            margin-bottom: 25px;
        }

        #clearDataBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            color: var(--grey-text);
            font-size: 22px;
            cursor: pointer;
            transition: color 0.2s ease-in-out, transform 0.2s ease-in-out;
            padding: 5px;
            z-index: 10;
        }
        #clearDataBtn:hover {
            color: var(--blue-primary);
            transform: scale(1.1);
        }
        #clearDataBtn:active {
            transform: scale(0.95);
        }

        /* Custom Dropdown Styles */
        .custom-dropdown {
            position: relative;
            width: 100%;
            max-width: 200px;
            margin-bottom: 0;
        }

        .dropdown-display {
            padding: 12px 18px;
            font-size: 1.1em;
            border-radius: 8px;
            border: 2px solid var(--blue-active-border);
            background: var(--bg-dark-charcoal);
            color: var(--white-off);
            outline: none;
            box-shadow: 0 0 0 3px var(--blue-to-cyan-glow);
            font-weight: 500;
            width: 100%;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            transition: border-color 0.2s, box-shadow 0.2s;
            height: 50px; /* Explicit height to ensure consistency */
        }

        .dropdown-display:hover, .dropdown-display:focus {
            border-color: var(--blue-active-border);
            box-shadow: 0 0 0 3px var(--blue-to-cyan-glow);
        }

        .dropdown-display::after {
            content: '\f078';
            font-family: "Font Awesome 5 Free";
            font-weight: 900;
            margin-left: 10px;
            transition: transform 0.2s;
        }

        .dropdown-display.open::after {
            transform: rotate(180deg);
        }

        .dropdown-options {
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            background: var(--bg-dark-charcoal);
            border: 2px solid var(--blue-active-border);
            border-top: none;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 5px 15px var(--shadow-dark);
            max-height: 200px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .dropdown-options.open {
            display: block;
        }

        .dropdown-options li {
            padding: 10px 18px;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s, color 0.2s;
            outline: none; /* Remove outline for focus, managed by JS visual cue */
        }

        .dropdown-options li:hover, .dropdown-options li.focused {
            background-color: rgba(66, 153, 225, 0.1);
        }

        .dropdown-options li.watched-option {
            background-color: var(--blue-watched);
            color: #fff;
        }

        .dropdown-options li.watched-option:hover, .dropdown-options li.watched-option.focused {
            background-color: #559DD9;
        }


        /* --- Episode grid/box styles like the image --- */
        #episodeListContainer {
            margin-top: 30px;
            padding: 20px;
            background: var(--bg-dark-charcoal);
            border-radius: 12px;
            box-shadow: 0 0 15px 8px var(--blue-to-cyan-glow);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 18px 16px;
            margin-bottom: 20px;
            justify-items: center;
        }
        .episode-item-rm {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background: var(--bg-medium-charcoal);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            border: 3px solid var(--bg-medium-charcoal);
            box-shadow: 0 2px 8px var(--shadow-dark);
            min-width: 160px;
            max-width: 200px;
            transition: border 0.2s, box-shadow 0.2s, background 0.2s, transform 0.2s ease-in-out;
            position: relative;
        }
        .episode-item-rm.watched {
            border: 3px solid var(--blue-watched);
            background: #222e3a;
        }
        .episode-item-rm.active {
            border: 3px solid var(--blue-active-border);
            background: var(--blue-highlight-bg);
            box-shadow: var(--button-glow-light);
            transform: translateY(-2px);
        }
        .episode-item-rm.active:hover {
            border: 3px solid var(--blue-active-border);
            background: var(--blue-highlight-bg);
            box-shadow: var(--button-glow-hover);
            transform: translateY(-4px);
        }
        .episode-item-rm:hover:not(.active) {
            border: 3px solid var(--bg-medium-charcoal);
            box-shadow: 0 2px 8px var(--shadow-dark);
            transform: translateY(0);
        }

        .episode-thumbnail-rm {
            width: 100%;
            height: 100px;
            background: #222;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .episode-thumbnail-rm img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            border-radius: 0;
        }
        .episode-play-icon-rm {
            display: none;
        }
        .episode-info-rm {
            flex-grow: 1;
            padding: 10px 12px 8px 12px;
            text-align: left;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            min-height: 70px;
            position: relative;
        }
        .episode-title-rm {
            font-family: 'Roboto', sans-serif;
            font-weight: 700;
            font-size: 1em;
            margin-bottom: 4px;
            color: var(--white-off);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }
        .episode-description-rm {
            font-family: 'Open Sans', sans-serif;
            font-size: 0.85em;
            color: var(--grey-text);
            line-height: 1.3;
            max-height: 2.6em;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 6px;
            width: 100%;
        }
        .episode-number-badge {
            position: absolute;
            bottom: 5px;
            right: 5px;
            background: var(--blue-active-border);
            color: #fff;
            border-radius: 4px;
            width: 20px;
            height: 20px;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.75em;
            z-index: 2;
            box-shadow: 0 1px 4px var(--shadow-dark);
            transition: background 0.2s, color 0.2s;
        }
        .episode-item-rm.active .episode-number-badge {
            display: flex;
        }
        .episode-number-badge:hover {
            box-shadow: 0 1px 4px var(--shadow-dark);
        }
        .episode-item-rm.watched .episode-number-badge {
            background: var(--blue-active-border);
            color: #fff;
        }

        .episode-action-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .episode-action-buttons .action-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            min-width: 180px;
        }

        /* Search Bar Styles */
        .search-container {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            justify-content: center;
            align-items: center;
            width: 100%;
            max-width: 500px;
            margin-left: auto;
            margin-right: auto;
        }

        .search-container input[type="text"] {
            flex-grow: 1;
            padding: 12px 18px;
            font-size: 1.1em;
            border-radius: 8px;
            border: 2px solid var(--blue-active-border);
            background: var(--bg-dark-charcoal);
            color: var(--white-off);
            outline: none;
            box-shadow: 0 0 0 3px var(--blue-to-cyan-glow);
            font-weight: 500;
        }

        .search-container button {
            padding: 12px;
            font-size: 1.1em;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: 700;
            background-color: var(--blue-primary);
            color: #fff;
            box-shadow: var(--button-glow-light);
            transition: box-shadow 0.2s ease-in-out, transform 0.2s ease-in-out;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .search-container button:hover {
            box-shadow: var(--button-glow-hover);
            transform: translateY(-2px);
        }

        /* Search Results Styles */
        #searchResults {
            margin-top: 20px;
            padding: 15px;
            background: var(--bg-dark-charcoal);
            border-radius: 12px;
            box-shadow: 0 0 10px 5px rgba(0, 191, 255, 0.4);
            max-height: 400px;
            overflow-y: auto;
            display: none;
            text-align: left;
        }

        .search-result-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 8px 10px;
            border-bottom: 1px solid var(--grey-border);
            cursor: pointer;
            transition: background-color 0.2s;
            max-width: 100%;
            box-sizing: border-box;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background-color: rgba(66, 153, 225, 0.1);
        }

        .search-result-info h4 {
            margin: 0;
            color: var(--white-off);
            font-size: 1em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Loading Indicator Styles */
        .loading-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: var(--blue-primary);
            font-size: 1.2em;
            font-weight: 600;
            gap: 10px;
        }

        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid var(--blue-primary);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Responsive grid for mobile */
        @media (max-width: 700px) {
            body {
                padding: 10px;
            }
            .container {
                padding: 15px;
            }
            h1 {
                font-size: 2em;
            }
            .selection-row {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }
            .selects-container-desktop {
                flex-direction: column;
                width: 100%;
                gap: 15px;
            }
            .control-group {
                width: 100%;
                align-items: center;
            }
            .custom-dropdown {
                max-width: 100%;
            }

            #episodeListContainer {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                padding: 10px;
            }
            .episode-item-rm {
                min-width: unset;
                max-width: 100%;
                width: 100%;
                height: 100%;
                aspect-ratio: 16/9;
            }
            .episode-thumbnail-rm {
                height: 100%;
                width: 100%;
                object-fit: cover;
                display: block;
                border-radius: 0;
            }

            .episode-title-rm, .episode-description-rm, .episode-info-rm {
                display: none;
            }

            .episode-number-badge {
                width: 18px;
                height: 18px;
                font-size: 0.6em;
                bottom: 3px;
                right: 3px;
                border-radius: 3px;
            }

            .search-container {
                flex-direction: row;
                max-width: 100%;
                align-items: center;
                justify-content: center;
            }
            .search-container input[type="text"] {
                width: auto;
                flex-grow: 1;
                min-width: 0;
                padding: 8px 12px;
                font-size: 1em;
            }
            .search-container button {
                width: 40px;
                height: 40px;
                padding: 0;
                font-size: 1.2em;
                flex-shrink: 0;
            }
            .search-container button span {
                display: none;
            }
        }
    </style>
</head>
<body>

<div class="container">
    <button id="clearDataBtn" title="Clear all data"><i class="fas fa-trash-alt"></i></button>
    <h1 id="showTitle">My TV Shows</h1>

    <div class="search-container">
        <input type="text" id="showSearchInput" placeholder="Search for a TV Show...">
        <button id="searchShowBtn"><i class="fas fa-search"></i></button>
    </div>

    <div id="searchResults">
        <!-- Search results will be displayed here -->
    </div>

    <!-- Loading Indicator for main content -->
    <div id="mainContentLoading" class="loading-indicator" style="display: none;">
        <div class="loading-spinner"></div>
        <span>Loading show data...</span>
    </div>

    <div id="contentArea" class="content-area">
        <iframe id="videoPlayer" src="" frameborder="0" allowfullscreen></iframe>

        <div class="selection-row">
            <div class="selects-container-desktop">
                <div class="control-group">
                    <label for="seasonSelectDisplay">Season:</label>
                    <div id="seasonSelect" class="custom-dropdown" role="combobox" aria-haspopup="listbox" aria-expanded="false" aria-labelledby="seasonSelectDisplay">
                        <div class="dropdown-display" id="seasonSelectDisplay" tabindex="0">Season 1</div>
                        <ul class="dropdown-options" id="seasonOptions" role="listbox"></ul>
                    </div>
                </div>
                <div class="control-group">
                    <label for="episodeSelectDisplay">Episode:</label>
                    <div id="episodeSelect" class="custom-dropdown" role="combobox" aria-haspopup="listbox" aria-expanded="false" aria-labelledby="episodeSelectDisplay">
                        <div class="dropdown-display" id="episodeSelectDisplay" tabindex="0">Episode 1</div>
                        <ul class="dropdown-options" id="episodeOptions" role="listbox"></ul>
                    </div>
                </div>
            </div>
        </div>

        <div id="episodeListContainer" style="margin-top: 30px;"></div>
        <div class="episode-action-buttons" style="margin-top: 35px;">
            <button id="loadMoreBtn" class="action-button">
            <i class="fas fa-plus-circle"></i> <span>Load More</span>
            </button>
            <button id="showLessBtn" class="action-button">
            <i class="fas fa-minus-circle"></i> <span>Show Less</span>
            </button>
        </div>
    </div>
</div>

<div id="customModalOverlay" class="modal-overlay">
    <div class="modal-content">
        <h3 id="modalTitle"></h3>
        <p id="modalMessage"></p>
        <div class="modal-buttons">
            <button id="modalConfirmBtn" class="modal-btn confirm-btn" style="display: none;">OK</button>
            <button id="modalCancelBtn" class="modal-btn cancel-btn" style="display: none;">Cancel</button>
            <button id="modalCloseBtn" class="modal-btn cancel-btn" style="display: none;">Close</button>
        </div>
    </div>
</div>

<script type="module">
    // --- Global Variables ---
    let watchedData = {}; // Stores watched status for shows in local storage
    let progressData = {}; // Stores playback progress for shows in local storage
    let lastWatchedData = {}; // Stores last watched episode for shows in local storage

    // Local Storage Fallback Keys - now include TMDB ID to differentiate data for different shows
    const WATCHED_KEY_PREFIX = 'tvShowWatched_';
    const PROGRESS_KEY_PREFIX = 'tvShowProgress_';
    const LAST_WATCHED_KEY_PREFIX = 'tvShowLastWatched_';
    const LAST_SHOW_ID_KEY = 'lastWatchedShowId'; // New key for last watched show ID
    const LAST_SHOW_NAME_KEY = 'lastWatchedShowName'; // New key for last watched show Name

    // TMDB and Episode Data Constants
    const PLACEHOLDER_IMAGE = 'https://placehold.co/160x90/1A1A1A/FFFFFF?text=NO+IMAGE';
    const EPISODES_DISPLAY_WINDOW_SIZE = 10;
    // IMPORTANT: THESE ARE YOUR PROVIDED TMDB API KEYS.
    // If you continue to experience "Status: 401" errors, please double-check these values directly from your TMDB account.
    // Go to themoviedb.org -> Profile -> API to ensure they are valid and active.
    const TMDB_API_KEY = 'd62d816a3f48ed18c1dc5e157f4d73b2';
    const TMDB_READ_TOKEN = 'eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJkNjJkODE2YTNmNDhlZDE4YzFkYzVlMTU3ZjRkNzNiMiIsIm5iZiI6MTc0OTYyMjI0MS4wMjQsInN1YiI6IjY4NDkxZGUxMDQ2NzYwZGI4YTlmNTg1ZCIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.UXLSaRBtR2aOvUObbrT3C4ctJcNG6MXTDjh1gu8y2Ks';

    // Default show ID and name, will be updated by search or loaded from local storage
    let currentTMDBShowId = 1433; // Default to American Dad
    let currentTMDBShowName = "American Dad!"; // Default show name

    let episodeMetadata = {}; // Stores all fetched episode metadata for the current show
    let totalSeasons = 20; // Default, will be updated by TMDB fetch

    let currentSeason = 1;
    let currentEpisode = 1; // Track current episode separately
    let currentEpisodesDisplayedCount = EPISODES_DISPLAY_WINDOW_SIZE; // Tracks how many episodes are currently rendered
    let isShowingAllEpisodes = false;
    let isLoadingData = false; // New loading state variable

    // --- DOM Elements ---
    const showTitleElement = document.getElementById('showTitle');
    const showSearchInput = document.getElementById('showSearchInput');
    const searchShowBtn = document.getElementById('searchShowBtn');
    const searchResultsDiv = document.getElementById('searchResults');
    const mainContentLoadingDiv = document.getElementById('mainContentLoading'); // New loading indicator div
    const videoPlayer = document.getElementById('videoPlayer');
    const episodeListContainer = document.getElementById('episodeListContainer');

    // Custom Dropdown Elements
    const seasonSelectDiv = document.getElementById('seasonSelect');
    const seasonSelectDisplay = document.getElementById('seasonSelectDisplay');
    const seasonOptionsUl = document.getElementById('seasonOptions');

    const episodeSelectDiv = document.getElementById('episodeSelect');
    const episodeSelectDisplay = document.getElementById('episodeSelectDisplay');
    const episodeOptionsUl = document.getElementById('episodeOptions');

    const loadMoreBtn = document.getElementById('loadMoreBtn');
    const showLessBtn = document.getElementById('showLessBtn');


    let lastIframeTime = 0;

    // Listen for messages from the Vidfast iframe to get current time
    window.addEventListener('message', (event) => {
        if (event.origin && !event.origin.includes('vidfast.pro')) return;
        if (typeof event.data === 'object' && event.data && event.data.type === 'currentTime') {
            lastIframeTime = Math.floor(event.data.time || 0);
            // Only update last watched time for the current episode
            setLastWatchedCurrentShow(currentSeason, currentEpisode, lastIframeTime, false);
        }
    });

    // Helper to request current time from Vidfast iframe
    function requestIframeCurrentTime() {
        if (videoPlayer && videoPlayer.contentWindow) {
            videoPlayer.contentWindow.postMessage({ type: 'getCurrentTime' }, '*');
        }
    }

    // Save time when user leaves the iframe (tab switch, click away, etc.)
    videoPlayer.addEventListener('blur', () => {
        requestIframeCurrentTime();
    });

    // Close custom dropdowns when clicking outside
    document.addEventListener('click', (event) => {
        if (!seasonSelectDiv.contains(event.target)) {
            closeDropdown(seasonSelectDisplay, seasonOptionsUl);
        }
        if (!episodeSelectDiv.contains(event.target)) {
            closeDropdown(episodeSelectDisplay, episodeOptionsUl);
        }
    });

    // --- Custom Modal Function ---
    function showCustomModal(message, type = 'alert', onConfirm = null) {
        const modalOverlay = document.getElementById('customModalOverlay');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');
        const modalCancelBtn = document.getElementById('modalCancelBtn');
        const modalCloseBtn = document.getElementById('modalCloseBtn');

        // Hide all buttons by default
        modalConfirmBtn.style.display = 'none';
        modalCancelBtn.style.display = 'none';
        modalCloseBtn.style.display = 'none';

        // Clear previous event listeners
        modalConfirmBtn.onclick = null;
        modalCancelBtn.onclick = null;
        modalCloseBtn.onclick = null;

        modalMessage.textContent = message;

        if (type === 'confirm') {
            modalTitle.textContent = 'Confirm Action';
            modalConfirmBtn.textContent = 'Confirm';
            modalConfirmBtn.style.display = 'inline-block';
            modalCancelBtn.textContent = 'Cancel';
            modalCancelBtn.style.display = 'inline-block';

            modalConfirmBtn.onclick = () => {
                modalOverlay.classList.remove('visible'); // Hide modal with transition
                if (onConfirm) onConfirm(true);
            };
            modalCancelBtn.onclick = () => {
                modalOverlay.classList.remove('visible'); // Hide modal with transition
                if (onConfirm) onConfirm(false);
            };
        } else { // type === 'alert'
            modalTitle.textContent = 'Notification';
            modalCloseBtn.textContent = 'Close';
            modalCloseBtn.onclick = () => {
                modalOverlay.classList.remove('visible'); // Hide modal with transition
            };
            modalCloseBtn.style.display = 'inline-block';
        }
        modalOverlay.classList.add('visible'); // Show modal with transition
    }


    // --- Local Storage Functions (now the primary data storage) ---
    function getWatchedLocal() {
        try {
            const stored = localStorage.getItem(WATCHED_KEY_PREFIX + currentTMDBShowId);
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            console.error("Error parsing local watched data:", e);
            return {};
        }
    }

    function setWatchedLocal(watched) {
        try {
            localStorage.setItem(WATCHED_KEY_PREFIX + currentTMDBShowId, JSON.stringify(watched));
        } catch (e) {
            console.error("Error setting local watched data:", e);
        }
    }

    function getProgressLocal() {
        try {
            const stored = localStorage.getItem(PROGRESS_KEY_PREFIX + currentTMDBShowId);
            return stored ? JSON.parse(stored) : {};
        } catch (e) {
            console.error("Error parsing local progress data:", e);
            return {};
        }
    }

    function setProgressLocal(progress) {
        try {
            localStorage.setItem(PROGRESS_KEY_PREFIX + currentTMDBShowId, JSON.stringify(progress));
        } catch (e) {
            console.error("Error setting local progress data:", e);
        }
    }

    function getLastWatchedLocal() {
        try {
            const stored = localStorage.getItem(LAST_WATCHED_KEY_PREFIX + currentTMDBShowId);
            return stored ? JSON.parse(stored) : null;
        } catch (e) {
            console.error("Error parsing local last watched data:", e);
            return null;
        }
    }

    function setLastWatchedLocal(season, episode, seconds, finished) {
        try {
            localStorage.setItem(LAST_WATCHED_KEY_PREFIX + currentTMDBShowId, JSON.stringify({ season, episode, seconds, finished }));
        } catch (e) {
            console.error("Error setting local last watched data:", e);
        }
    }

    // --- Wrapped Data Access Functions (Simplified for Local Only) ---
    // These functions now *only* use local storage functions
    function getWatchedCurrentShow() {
        return getWatchedLocal();
    }

    function setWatchedCurrentShow(watchedForThisShow) {
        setWatchedLocal(watchedForThisShow);
    }

    function getProgressCurrentShow() {
        return getProgressLocal();
    }

    function setProgressCurrentShow(progressForThisShow) {
        setProgressLocal(progressForThisShow);
    }

    function getLastWatchedCurrentShow() {
        return getLastWatchedLocal();
    }

    function setLastWatchedCurrentShow(season, episode, seconds, finished) {
        setLastWatchedLocal(season, episode, seconds, finished);
    }


    // --- TMDB API Interaction for Episode Data ---
    async function fetchEpisodeData() {
        isLoadingData = true;
        mainContentLoadingDiv.style.display = 'flex'; // Show loading indicator
        document.getElementById('contentArea').style.display = 'none'; // Hide content while loading

        try {
            // Update the show title
            showTitleElement.textContent = currentTMDBShowName;

            // Ensure TMDB_READ_TOKEN is present for fetching show details
            if (!TMDB_READ_TOKEN) {
                throw new Error("TMDB_READ_TOKEN is missing. Cannot fetch show details.");
            }

            const showDetailsResponse = await fetch(`https://api.themoviedb.org/3/tv/${currentTMDBShowId}`, {
                headers: {
                    'Authorization': `Bearer ${TMDB_READ_TOKEN}`,
                    'accept': 'application/json'
                }
            });
            if (!showDetailsResponse.ok) {
                const errorData = await showDetailsResponse.json().catch(() => ({}));
                const errorMessage = errorData.status_message || showDetailsResponse.statusText;
                throw new Error(`Failed to fetch show details: ${showDetailsResponse.status} - ${errorMessage}. Please check your TMDB API keys.`);
            }
            const showDetails = await showDetailsResponse.json();
            totalSeasons = showDetails.number_of_seasons;

            const seasonPromises = [];
            for (let s = 1; s <= totalSeasons; s++) {
                seasonPromises.push(
                    fetch(`https://api.themoviedb.org/3/tv/${currentTMDBShowId}/season/${s}`, {
                        headers: {
                            'Authorization': `Bearer ${TMDB_READ_TOKEN}`,
                            'accept': 'application/json'
                        }
                    }).then(res => res.ok ? res.json() : null)
                );
            }

            const seasons = await Promise.all(seasonPromises);
            episodeMetadata = {}; // Reset episode metadata for the new show
            seasons.forEach((seasonObj) => {
                const seasonNum = seasonObj?.season_number?.toString();
                if (seasonNum && seasonObj.episodes) {
                    episodeMetadata[seasonNum] = {};
                    seasonObj.episodes.forEach(ep => {
                        episodeMetadata[seasonNum][ep.episode_number.toString()] = {
                            title: ep.name || `Episode ${ep.episode_number}`,
                            description: ep.overview || 'Description not available.',
                            image: ep.still_path ? `https://image.tmdb.org/t/p/w300${ep.still_path}` : PLACEHOLDER_IMAGE
                        };
                    });
                }
            });

            // Fallback for seasons with no episodes or to ensure a minimum number of episodes
            for (let s = 1; s <= totalSeasons; s++) {
                const seasonStr = s.toString();
                if (!episodeMetadata[seasonStr]) {
                    episodeMetadata[seasonStr] = {};
                }
                // If TMDB returns no episodes for a season, default to 22 episodes for consistency
                const numEpisodesInSeason = Object.keys(episodeMetadata[seasonStr]).length > 0 ? Object.keys(episodeMetadata[seasonStr]).length : 22;
                for (let e = 1; e <= numEpisodesInSeason; e++) {
                    const episodeStr = e.toString();
                    if (!episodeMetadata[seasonStr][episodeStr]) {
                        episodeMetadata[seasonStr][episodeStr] = {
                            title: `Season ${s}, Episode ${e}`,
                            description: `This is a generic description for Season ${s}, Episode ${e}.`,
                            image: PLACEHOLDER_IMAGE
                        };
                    }
                }
            }

            // Set current season and episode based on last watched, or default to S1E1
            const lastWatched = getLastWatchedCurrentShow();
            if (lastWatched && lastWatched.season && lastWatched.episode) {
                currentSeason = lastWatched.season;
                currentEpisode = lastWatched.episode;
            } else {
                currentSeason = 1;
                currentEpisode = 1;
            }

            currentEpisodesDisplayedCount = EPISODES_DISPLAY_WINDOW_SIZE; // Reset displayed count
            isShowingAllEpisodes = false; // Reset show all flag

            renderSeasonSelect(); // Render custom season dropdown
            renderEpisodeSelect(); // Render custom episode dropdown based on currentSeason
            renderEpisodeList(true); // Initial render of episode grid, full refresh

            // Load the video for the automatically selected episode
            updateVideoPlayer(true); // Pass true for initial load to consider last watched time

        } catch (e) {
            console.error('Error loading episode data from TMDB API:', e);
            showCustomModal('Failed to load show data: ' + e.message + '. Displaying generic content.', 'alert');
            // Populate dropdowns with default values even if TMDB fails
            if (totalSeasons === 20) { // If totalSeasons was never updated by TMDB
                for (let s = 1; s <= 20; s++) {
                    const seasonStr = s.toString();
                    if (!episodeMetadata[seasonStr]) {
                        episodeMetadata[seasonStr] = {};
                    }
                    for (let e = 1; e <= 22; e++) {
                        const episodeStr = e.toString();
                        if (!episodeMetadata[seasonStr][episodeStr]) {
                            episodeMetadata[seasonStr][episodeStr] = {
                                title: `Season ${s}, Episode ${e}`,
                                description: `This is a generic description for Season ${s}, Episode ${e}.`,
                                image: PLACEHOLDER_IMAGE
                            };
                        }
                    }
                }
            }
            // Ensure currentSeason and currentEpisode are set even after an error
            const lastWatched = getLastWatchedCurrentShow();
            if (lastWatched && lastWatched.season && lastWatched.episode) {
                currentSeason = lastWatched.season;
                currentEpisode = lastWatched.episode;
            } else {
                currentSeason = 1;
                currentEpisode = 1;
            }
            currentEpisodesDisplayedCount = EPISODES_DISPLAY_WINDOW_SIZE; // Reset displayed count
            isShowingAllEpisodes = false; // Reset show all flag

            renderSeasonSelect();
            renderEpisodeSelect();
            renderEpisodeList(true);
            updateVideoPlayer(true); // Still try to play if possible
        } finally {
            isLoadingData = false;
            mainContentLoadingDiv.style.display = 'none'; // Hide loading indicator
            document.getElementById('contentArea').style.display = 'block'; // Show content
        }
    }

    // --- Custom Dropdown Logic ---
    function createDropdownOption(value, text, isWatched) {
        const li = document.createElement('li');
        li.dataset.value = value;
        li.textContent = text;
        li.setAttribute('role', 'option');
        if (isWatched) {
            li.classList.add('watched-option');
        }
        return li;
    }

    function openDropdown(displayElement, optionsListElement) {
        displayElement.classList.add('open');
        displayElement.setAttribute('aria-expanded', 'true');
        optionsListElement.classList.add('open');
    }

    function closeDropdown(displayElement, optionsListElement) {
        displayElement.classList.remove('open');
        displayElement.setAttribute('aria-expanded', 'false');
        optionsListElement.classList.remove('open');
        // Remove focused class from all options when dropdown closes
        optionsListElement.querySelectorAll('.focused').forEach(el => el.classList.remove('focused'));
    }

    function renderSeasonSelect() {
        seasonOptionsUl.innerHTML = ''; // Clear existing options
        for (let s = 1; s <= totalSeasons; s++) {
            const optionText = `Season ${s}`;
            const li = createDropdownOption(s, optionText, false);
            seasonOptionsUl.appendChild(li);

            li.addEventListener('click', () => {
                selectSeason(parseInt(li.dataset.value));
                closeDropdown(seasonSelectDisplay, seasonOptionsUl);
            });
        }
        seasonSelectDisplay.textContent = `Season ${currentSeason}`;
        seasonSelectDisplay.setAttribute('aria-valuenow', currentSeason);
    }

    function renderEpisodeSelect() {
        episodeOptionsUl.innerHTML = ''; // Clear existing options
        const episodesInCurrentSeason = episodeMetadata[currentSeason] ? Object.keys(episodeMetadata[currentSeason]).length : 0;
        const numEpisodesToRender = episodesInCurrentSeason > 0 ? episodesInCurrentSeason : 22;

        const watched = getWatchedCurrentShow();

        for (let i = 1; i <= numEpisodesToRender; i++) {
            const isEpisodeWatched = watched[currentSeason] && watched[currentSeason].includes(i);
            const optionText = `Episode ${i}`;
            const li = createDropdownOption(i, optionText, isEpisodeWatched);
            episodeOptionsUl.appendChild(li);

            li.addEventListener('click', () => {
                selectEpisode(currentSeason, parseInt(li.dataset.value));
                closeDropdown(episodeSelectDisplay, episodeOptionsUl);
            });
        }
        episodeSelectDisplay.textContent = `Episode ${currentEpisode}`;
        episodeSelectDisplay.setAttribute('aria-valuenow', currentEpisode);
    }

    // Toggle dropdown visibility
    seasonSelectDisplay.addEventListener('click', () => {
        const isOpen = seasonOptionsUl.classList.contains('open');
        if (isOpen) {
            closeDropdown(seasonSelectDisplay, seasonOptionsUl);
        } else {
            openDropdown(seasonSelectDisplay, seasonOptionsUl);
            closeDropdown(episodeSelectDisplay, episodeOptionsUl); // Close other dropdown
        }
    });

    episodeSelectDisplay.addEventListener('click', () => {
        const isOpen = episodeOptionsUl.classList.contains('open');
        if (isOpen) {
            closeDropdown(episodeSelectDisplay, episodeOptionsUl);
        } else {
            openDropdown(episodeSelectDisplay, episodeOptionsUl);
            closeDropdown(seasonSelectDisplay, seasonOptionsUl); // Close other dropdown
        }
    });

    // Keyboard navigation for custom dropdowns
    function handleDropdownKeyboard(event, displayElement, optionsListElement, selectFn) {
        const isOpen = optionsListElement.classList.contains('open');
        let currentFocused = optionsListElement.querySelector('.focused');

        if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            if (isOpen) {
                if (currentFocused) {
                    selectFn(currentFocused.dataset.value);
                }
                closeDropdown(displayElement, optionsListElement);
            } else {
                openDropdown(displayElement, optionsListElement);
                // Focus first option when opening
                const firstOption = optionsListElement.querySelector('li');
                if (firstOption) {
                    firstOption.classList.add('focused');
                }
            }
        } else if (event.key === 'Escape') {
            event.preventDefault();
            closeDropdown(displayElement, optionsListElement);
            displayElement.focus(); // Return focus to the display button
        } else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
            event.preventDefault();
            if (!isOpen) {
                openDropdown(displayElement, optionsListElement);
                currentFocused = optionsListElement.querySelector('li'); // Focus first if not open
            }

            const options = Array.from(optionsListElement.children);
            let nextIndex = -1;

            if (currentFocused) {
                currentFocused.classList.remove('focused');
                const currentIndex = options.indexOf(currentFocused);
                if (event.key === 'ArrowDown') {
                    nextIndex = (currentIndex + 1) % options.length;
                } else { // ArrowUp
                    nextIndex = (currentIndex - 1 + options.length) % options.length;
                }
            } else {
                // If nothing focused, focus first on ArrowDown, last on ArrowUp
                nextIndex = (event.key === 'ArrowDown') ? 0 : options.length - 1;
            }

            if (options[nextIndex]) {
                options[nextIndex].classList.add('focused');
                options[nextIndex].scrollIntoView({ block: 'nearest' });
            }
        }
    }

    seasonSelectDisplay.addEventListener('keydown', (event) => handleDropdownKeyboard(event, seasonSelectDisplay, seasonOptionsUl, (value) => selectSeason(parseInt(value))));
    episodeSelectDisplay.addEventListener('keydown', (event) => handleDropdownKeyboard(event, episodeSelectDisplay, episodeOptionsUl, (value) => selectEpisode(currentSeason, parseInt(value))));


    function selectSeason(seasonNum) {
        if (currentSeason !== seasonNum) {
            currentSeason = seasonNum;
            currentEpisode = 1; // Reset episode to 1 when season changes
            renderEpisodeSelect();
            // Re-render episode list from scratch when season changes
            currentEpisodesDisplayedCount = EPISODES_DISPLAY_WINDOW_SIZE;
            isShowingAllEpisodes = false;
            renderEpisodeList(true); // Full refresh
            updateVideoPlayer(false); // Do not use last watched time when manually changing season
        }
        seasonSelectDisplay.textContent = `Season ${currentSeason}`;
        seasonSelectDisplay.setAttribute('aria-valuenow', currentSeason);
    }

    function selectEpisode(season, episode) {
        // Ensure currentSeason is updated if selecting an episode from a different season via search result
        // (though current implementation always sets currentSeason first via selectSeason or initial load)
        currentSeason = season;
        if (currentEpisode !== episode) {
            currentEpisode = episode;
            // Update the display text for the episode dropdown
            episodeSelectDisplay.textContent = `Episode ${currentEpisode}`;
            episodeSelectDisplay.setAttribute('aria-valuenow', currentEpisode);
            renderEpisodeList(false); // Update active state, no full refresh if only episode changed
            updateVideoPlayer(false); // Do not use last watched time when manually changing episode
        }
    }

    function renderEpisodeList(fullRefresh = false) {
        const episodesInSeason = episodeMetadata[currentSeason] || {};
        const episodeNumbers = Object.keys(episodesInSeason).map(Number).sort((a, b) => a - b);

        if (fullRefresh) {
            episodeListContainer.innerHTML = ''; // Clear existing episodes only on full refresh
            currentEpisodesDisplayedCount = EPISODES_DISPLAY_WINDOW_SIZE;
            isShowingAllEpisodes = false;
        }

        const currentDisplayedEpisodeElements = Array.from(episodeListContainer.children);
        let numCurrentlyRendered = currentDisplayedEpisodeElements.length;

        const targetDisplayCount = isShowingAllEpisodes ? episodeNumbers.length : EPISODES_DISPLAY_WINDOW_SIZE;

        // If we are showing less, remove elements that are beyond EPISODES_DISPLAY_WINDOW_SIZE
        if (!isShowingAllEpisodes && numCurrentlyRendered > EPISODES_DISPLAY_WINDOW_SIZE) {
            while (episodeListContainer.children.length > EPISODES_DISPLAY_WINDOW_SIZE) {
                episodeListContainer.removeChild(episodeListContainer.lastChild);
            }
            numCurrentlyRendered = EPISODES_DISPLAY_WINDOW_SIZE;
        }

        const fragment = document.createDocumentFragment();

        // Append new episodes if targetDisplayCount is greater than currently rendered
        for (let i = numCurrentlyRendered; i < targetDisplayCount; i++) {
            const episodeNum = episodeNumbers[i];
            if (!episodeNum) continue;

            const episode = episodesInSeason[episodeNum.toString()];
            if (!episode) continue;

            const episodeItem = document.createElement('div');
            episodeItem.classList.add('episode-item-rm');
            episodeItem.dataset.season = currentSeason;
            episodeItem.dataset.episode = episodeNum;

            const watched = getWatchedCurrentShow();
            if (watched[currentSeason] && watched[currentSeason].includes(episodeNum)) {
                episodeItem.classList.add('watched');
            }

            // Set as active if it's the currently selected episode
            if (parseInt(currentSeason) === parseInt(episodeItem.dataset.season) && parseInt(episodeNum) === parseInt(currentEpisode)) {
                episodeItem.classList.add('active');
            }

            episodeItem.innerHTML = `
                <div class="episode-thumbnail-rm">
                    <img src="${episode.image}" alt="Episode ${episodeNum} Thumbnail" onerror="this.onerror=null; this.src='${PLACEHOLDER_IMAGE}';">
                    <span class="episode-number-badge">${episodeNum}</span>
                </div>
                <div class="episode-info-rm">
                    <div class="episode-title-rm">${episode.title}</div>
                    <div class="episode-description-rm">${episode.description}</div>
                </div>
            `;
            fragment.appendChild(episodeItem);

            episodeItem.addEventListener('click', () => {
                selectEpisode(parseInt(episodeItem.dataset.season), parseInt(episodeItem.dataset.episode));
            });
        }
        episodeListContainer.appendChild(fragment);

        // Update active state for all displayed episodes
        episodeListContainer.querySelectorAll('.episode-item-rm').forEach(item => {
            if (parseInt(item.dataset.season) === currentSeason && parseInt(item.dataset.episode) === currentEpisode) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }
        });

        // Update watched status for all displayed episodes (important after a watch action)
        const watched = getWatchedCurrentShow();
        episodeListContainer.querySelectorAll('.episode-item-rm').forEach(item => {
            const epSeason = parseInt(item.dataset.season);
            const epEpisode = parseInt(item.dataset.episode);
            if (watched[epSeason] && watched[epSeason].includes(epEpisode)) {
                item.classList.add('watched');
            } else {
                item.classList.remove('watched');
            }
        });

        // Handle Load More/Show Less buttons visibility
        if (episodeNumbers.length > EPISODES_DISPLAY_WINDOW_SIZE) {
            if (isShowingAllEpisodes) {
                loadMoreBtn.style.display = 'none';
                showLessBtn.style.display = 'inline-block';
            } else {
                loadMoreBtn.style.display = 'inline-block';
                showLessBtn.style.display = 'none';
            }
        } else {
            loadMoreBtn.style.display = 'none';
            showLessBtn.style.display = 'none';
        }
    }

    function updateVideoPlayer(initialLoad = false) {
        let secondsToStart = 0;
        if (initialLoad) {
            const lastWatched = getLastWatchedCurrentShow();
            if (lastWatched && lastWatched.season === currentSeason && lastWatched.episode === currentEpisode && typeof lastWatched.seconds === 'number' && lastWatched.seconds > 0 && !lastWatched.finished) {
                secondsToStart = lastWatched.seconds;
            }
        }

        const url = `https://vidfast.pro/tv/${currentTMDBShowId}/${currentSeason}/${currentEpisode}?autoPlay=true&nextButton=true&autoNext=true&theme=#1e90ff${secondsToStart > 0 ? '#' + secondsToStart : ''}`;
        videoPlayer.src = url;

        // Mark as watched after playing for a certain duration (e.g., 10 seconds)
        if (window.markWatchedTimeout) {
            clearTimeout(window.markWatchedTimeout);
        }
        window.markWatchedTimeout = setTimeout(() => {
            let watched = getWatchedCurrentShow();
            if (!watched[currentSeason]) {
                watched[currentSeason] = [];
            }
            if (!watched[currentSeason].includes(parseInt(currentEpisode))) {
                watched[currentSeason].push(parseInt(currentEpisode));
                setWatchedCurrentShow(watched);
                renderEpisodeSelect(); // Update dropdown option color for watched
                renderEpisodeList(false); // Update episode grid for watched status without full refresh
            }
        }, 10000); // Mark as watched after 10 seconds
    }


    // --- Event Listeners ---
    // Clear Data Button
    document.getElementById('clearDataBtn').addEventListener('click', () => {
        showCustomModal('Are you sure you want to clear all watched data and progress for all shows? This cannot be undone.', 'confirm', async (response) => {
            if (response) {
                // Always clear local storage data and cookies for all shows
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith(WATCHED_KEY_PREFIX) || key.startsWith(PROGRESS_KEY_PREFIX) || key.startsWith(LAST_WATCHED_KEY_PREFIX) || key === LAST_SHOW_ID_KEY || key === LAST_SHOW_NAME_KEY) {
                        localStorage.removeItem(key);
                    }
                });
                document.cookie.split(";").forEach(function(c) {
                    document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
                });
                console.log("Local storage and cookies cleared.");

                // Reset in-memory data that tracks local storage
                watchedData = {};
                progressData = {};
                lastWatchedData = {};

                // Reset to default show and episode
                currentTMDBShowId = 1433; // American Dad
                currentTMDBShowName = "American Dad!";
                currentSeason = 1;
                currentEpisode = 1;

                fetchEpisodeData(); // Re-fetch all data for the default show

                showCustomModal('All local data has been cleared.', 'alert');

                if (window.watchTimer) clearInterval(window.watchTimer);
            }
        });
    });

    // Load More/Show Less buttons
    loadMoreBtn.addEventListener('click', () => {
        isShowingAllEpisodes = true;
        renderEpisodeList(false); // Do not full refresh, just append
    });

    showLessBtn.addEventListener('click', () => {
        isShowingAllEpisodes = false;
        renderEpisodeList(false); // Do not full refresh, just remove excess
    });

    // --- Search Functionality ---
    searchShowBtn.addEventListener('click', () => {
        const query = showSearchInput.value.trim();
        if (query) {
            searchShows(query);
        } else {
            searchResultsDiv.innerHTML = '<p style="color: var(--grey-text);">Please enter a show name.</p>';
            searchResultsDiv.style.display = 'block';
        }
    });

    showSearchInput.addEventListener('keypress', (event) => {
        if (event.key === 'Enter') {
            searchShowBtn.click();
        }
    });

    async function searchShows(query) {
        searchResultsDiv.innerHTML = `
            <div class="loading-indicator">
                <div class="loading-spinner"></div>
                <span>Searching for shows...</span>
            </div>`;
        searchResultsDiv.style.display = 'block';

        // Explicit check for the TMDB_READ_TOKEN
        if (!TMDB_READ_TOKEN) {
            console.error("TMDB_READ_TOKEN is missing or empty. Please ensure it's correctly set in the code.");
            searchResultsDiv.innerHTML = '<p style="color: var(--red-primary);">TMDB API Read Access Token is missing or invalid. Please update the code with your valid TMDB token.</p>';
            return;
        }

        try {
            const response = await fetch(`https://api.themoviedb.org/3/search/tv?query=${encodeURIComponent(query)}`, {
                headers: {
                    'Authorization': `Bearer ${TMDB_READ_TOKEN}`,
                    'accept': 'application/json'
                }
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const errorMessage = errorData.status_message || response.statusText;
                throw new Error(`Failed to search shows. Status: ${response.status} - ${errorMessage}. Please ensure your TMDB API keys are correct and active.`);
            }
            const data = await response.json();
            displaySearchResults(data.results);
        } catch (error) {
            console.error('Error searching shows:', error);
            searchResultsDiv.innerHTML = `<p style="color: var(--red-primary);">Error searching for shows: ${error.message}.</p>`;
        }
    }

    function displaySearchResults(results) {
        searchResultsDiv.innerHTML = '';
        if (results.length === 0) {
            searchResultsDiv.innerHTML = '<p style="color: var(--grey-text);">No results found.</p>';
            return;
        }

        results.forEach(show => {
            const resultItem = document.createElement('div');
            resultItem.classList.add('search-result-item');
            // Display only the show name
            resultItem.innerHTML = `<h4>${show.name}</h4>`;
            searchResultsDiv.appendChild(resultItem);

            resultItem.addEventListener('click', () => {
                currentTMDBShowId = show.id;
                currentTMDBShowName = show.name;
                // Save the newly selected show as the last watched show
                localStorage.setItem(LAST_SHOW_ID_KEY, currentTMDBShowId);
                localStorage.setItem(LAST_SHOW_NAME_KEY, currentTMDBShowName);

                searchResultsDiv.style.display = 'none'; // Hide search results
                showSearchInput.value = ''; // Clear search input
                fetchEpisodeData(); // Load data for the newly selected show
            });
        });
    }

    // --- Initial Load Logic ---
    document.addEventListener('DOMContentLoaded', async () => {
        // Attempt to load last watched show from local storage first
        const storedShowId = localStorage.getItem(LAST_SHOW_ID_KEY);
        const storedShowName = localStorage.getItem(LAST_SHOW_NAME_KEY);

        if (storedShowId && storedShowName) {
            currentTMDBShowId = parseInt(storedShowId);
            currentTMDBShowName = storedShowName;
        }

        // Load data from local storage for current show (which might now be the last watched show)
        watchedData = getWatchedLocal();
        progressData = getProgressLocal();
        lastWatchedData = getLastWatchedLocal();

        // Fetch episode data to populate UI for the determined show
        fetchEpisodeData();
    });

</script>

</body>
</html>
